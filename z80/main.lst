; wpset F800,1,w,wpdata==39
; trace bst_test.tr,1,noloop
; wpset F800,1,w,wpdata==3A,{tracelog "A addr: 0x%02X; data: 0x%02X\n", d, e; go}
; wpset F800,1,w,wpdata==3B,{tracelog "B addr: 0x%02X; data: 0x%02X\n", d, e; go}
	
	include "def.inc"
; Memory map
FIXED       equ $0000
BANK3       equ $8000
BANK2       equ $C000
BANK1       equ $E000
BANK0       equ $F000
WRAM_START  equ $F800
WRAM_END    equ $FFFF

MLM_HEADER  equ FIXED+$4000
MLM_SONG2   equ BANK3
INSTRUMENTS equ BANK2
OTHER_DATA  equ BANK1

; Port map
READ_68K    equ $00
YM2610_A0   equ $04
YM2610_A1   equ $05
YM2610_B0   equ $06
YM2610_B1   equ $07
ENABLE_NMI  equ $08
WRITE_68K   equ $0C
DISABLE_NMI equ $18

; YM2610 SSG defines
REG_SSG_CHA_FINE_TUNE   equ $00
REG_SSG_CHA_COARSE_TUNE equ $01
REG_SSG_CHB_FINE_TUNE   equ $02
REG_SSG_CHB_COARSE_TUNE equ $03
REG_SSG_CHC_FINE_TUNE   equ $04
REG_SSG_CHC_COARSE_TUNE equ $05
REG_SSG_CHN_NOISE_TUNE  equ $06
REG_SSG_MIX_ENABLE     equ $07
REG_SSG_CHA_VOL        equ $08
REG_SSG_CHB_VOL        equ $09
REG_SSG_CHC_VOL        equ $0A
REG_SSG_VOL_ENV        equ $0B
REG_SSG_COARSE_ENV     equ $0C
REG_SSG_VOL_ENV_SHAPE  equ $0D

SSG_CHA equ $00
SSG_CHB equ $01
SSG_CHC equ $02

SSG_MIX_NONE      equ 0
SSG_MIX_TONE      equ 1
SSG_MIX_NOISE     equ 2
SSG_MIX_TONENOISE equ 3

; YM2610 FM registers
REG_FM_LFO_CNT equ $22
REG_FM_KEY_ON  equ $28

REG_FM_CH13_FNUM      equ $A1
REG_FM_CH13_FBLOCK    equ $A5
REG_FM_CH13_FBALGO    equ $B1
REG_FM_CH13_LRAMSPMS  equ $B5

REG_FM_CH24_FNUM     equ $A2
REG_FM_CH24_FBLOCK   equ $A6
REG_FM_CH24_FBALGO   equ $B2
REG_FM_CH24_LRAMSPMS  equ $B6

REG_FM_CH1_OP1_DTMUL equ $31
REG_FM_CH1_OP1_TVOL  equ $41
REG_FM_CH1_OP1_KSAR  equ $51
REG_FM_CH1_OP1_AMDR  equ $61
REG_FM_CH1_OP1_SUSR  equ $71
REG_FM_CH1_OP1_SLRR  equ $81
REG_FM_CH1_OP1_ENVGN equ $91

REG_FM_CH1_OP2_DTMUL equ $39
REG_FM_CH1_OP2_TVOL  equ $49
REG_FM_CH1_OP2_KSAR  equ $59
REG_FM_CH1_OP2_AMDR  equ $69
REG_FM_CH1_OP2_SUSR  equ $79
REG_FM_CH1_OP2_SLRR  equ $89
REG_FM_CH1_OP2_ENVGN equ $99

REG_FM_CH1_OP3_DTMUL equ $35
REG_FM_CH1_OP3_TVOL  equ $45
REG_FM_CH1_OP3_KSAR  equ $55
REG_FM_CH1_OP3_AMDR  equ $65
REG_FM_CH1_OP3_SUSR  equ $75
REG_FM_CH1_OP3_SLRR  equ $85
REG_FM_CH1_OP3_ENVGN equ $95

REG_FM_CH1_OP4_DTMUL equ $3D
REG_FM_CH1_OP4_TVOL  equ $4D
REG_FM_CH1_OP4_KSAR  equ $5D
REG_FM_CH1_OP4_AMDR  equ $6D
REG_FM_CH1_OP4_SUSR  equ $7D
REG_FM_CH1_OP4_SLRR  equ $8D
REG_FM_CH1_OP4_ENVGN equ $9D

; YM2610 Timer Registers
REG_TMA_COUNTER_MSB equ $24
REG_TMA_COUNTER_LSB equ $25 ; ------TT
REG_TMB_COUNTER     equ $26
REG_TIMER_CNT       equ $27

; FM defines
FM_CH1 equ %001
FM_CH2 equ %010
FM_CH3 equ %101
FM_CH4 equ %110

FM_OP1      equ 0
FM_OP2      equ 1
FM_OP3      equ 2
FM_OP4      equ 3
FM_OP_COUNT equ 4

; ADPCM-A defines
REG_PA_CTRL		equ $00
REG_PA_MVOL		equ $01
REG_PA_CVOL		equ $08
REG_PA_STARTL	equ $10
REG_PA_STARTH	equ $18
REG_PA_ENDL		equ $20
REG_PA_ENDH		equ $28

; ADPCM-B defines
REG_PB_CTRL		equ $10
REG_PB_LRSEL	equ $11
REG_PB_STARTL	equ $12
REG_PB_STARTH	equ $13
REG_PB_ENDL		equ $14
REG_PB_ENDH		equ $15
REG_PB_FREQL	equ $19
REG_PB_FREQH	equ $1A
REG_PB_VOL		equ $1B
REG_P_FLAGS		equ $1C

; RSTs
RST_YM_DELAY1 equ $08
RST_YM_DELAY2 equ $10
RST_YM_WRITEA equ $18
RST_YM_WRITEB equ $20
RST_YM_READA equ $28

; Timer control
TM_CNT_LOAD_TA       equ %00000001
TM_CNT_LOAD_TB       equ %00000010
TM_CNT_ENABLE_TA_IRQ equ %00000100
TM_CNT_ENABLE_TB_IRQ equ %00001000
TM_CNT_TA_FLG_RESET  equ %00010000
TM_CNT_TB_FLG_RESET  equ %00100000
TM_CNT_2CH_MODE      equ %01000000
TM_CNT_CSM_MODE      equ %10000000

; MLM defines
NOTE_C  equ $0
NOTE_CS equ $1
NOTE_D  equ $2
NOTE_DS equ $3
NOTE_E  equ $4
NOTE_F  equ $5
NOTE_FS equ $6
NOTE_G  equ $7
NOTE_GS equ $8
NOTE_A  equ $9
NOTE_AS equ $A
NOTE_B  equ $B

PANNING_NONE   equ %00000000
PANNING_R      equ %01000000
PANNING_L      equ %10000000
PANNING_CENTER equ %11000000

CHANNEL_COUNT     equ 13
PA_CHANNEL_COUNT  equ 6
FM_CHANNEL_COUNT  equ 4
SSG_CHANNEL_COUNT equ 3

MLM_CH_PA1  equ 0
MLM_CH_PA2  equ 1
MLM_CH_PA3  equ 2
MLM_CH_PA4  equ 3
MLM_CH_PA5  equ 4
MLM_CH_PA6  equ 5
MLM_CH_FM1  equ 6
MLM_CH_FM2  equ 7
MLM_CH_FM3  equ 8
MLM_CH_FM4  equ 9
MLM_CH_SSG1 equ 10
MLM_CH_SSG2 equ 11
MLM_CH_SSG3 equ 12

; Should always be a multiple of 2
; and also be smaller than 128
COM_BUFFER_LENGTH equ 32
IRQ_BUFFER_LENGTH equ 16

UCOM_MASK         equ %01111111

; SSG driver definitions (driver into 
; the driver??? change name later)
SSGCNT_MIX_EN_TUNE	equ 0
SSGCNT_MIX_EN_NOISE	equ 3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                    MACROS                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	macro srl_hl
		srl h
		rr l
	endm

	macro brk
		push af
		ld a,$39
		ld (breakpoint),a
		pop af
	endm

	macro brk2
		push af
		ld a,$3A
		ld (breakpoint),a
		pop af
	endm

	macro brk3
		push af
		ld a,$3B
		ld (breakpoint),a
		pop af
	endm

	macro fm_ch_data fb,algo,ams,pms
		.db \algo | (\fb << 3)
		.db \pms | (\ams << 4)
	endm

	; deflemask:      dt,mul,tl,rs,a, am,d, d2,s, r, eg
	macro fm_op_data dt,mul,tl,ks,ar,am,dr,sr,sl,rr,eg
		.db \mul | (\dt << 4)
		.db \tl
		.db \ar | (\ks << 6)
		.db \dr | (\am << 7)
		.db \sr
		.db \rr | (\sl << 4)
		.db \eg
	endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                    STRUCT                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ControlMacro.enable  equ 0
ControlMacro.length  equ 1
ControlMacro.data    equ 2
ControlMacro.loop_pt equ 4
ControlMacro.curr_pt equ 5
ControlMacro.SIZE    equ 8

;	macro ControlMacro
;enable 	.ds 1 ; u8
;length 	.ds 1 ; u8
;data 	.ds 2 ; void*
;loop_pt	.ds 1 ; u8
;curr_pt	.ds 1 ; u8 (Current point)
;pad 	.ds 2 ; u8[2] 
;	endm

	macro ControlMacro
	.ds 1+1+2+1+1+2
	endm

	org $0000
j_startup:
	di
	jp startup

	org $0008
j_port_write_delay1:
	jp port_write_delay1

	org $0010
j_port_write_delay2:
	jp port_write_delay2

	org $0018
j_port_write_a:
	jp port_write_a

	org $0020
j_port_write_b:
	jp port_write_b

	org $0028
j_port_read_a:
	jp port_read_a

	org $0038
j_IRQ:
	di
	jp IRQ

	db "MZS driver v. 6.3-beta by GbaCretin"

	org $0066
NMI:
	push af
	push bc
	push de
	push hl
	push ix
	push iy
		in a,(READ_68K)
		or a,a ; cp a,$00
		jr z,NMI_do_nothing
		cp a,$01
		jp z,BCOM_prepare_switch
		cp a,$03
		jp z,BCOM_reset
		
		bit 7,a
		call nz,UCOM_write2buffer

		xor a,$FF
		;ld a,(tmp)
		out (WRITE_68K),a    ; reply to 68k
		out (READ_68K),a     ; clear sound code

NMI_do_nothing:
	pop iy
	pop ix
	pop hl
	pop de
	pop bc
	pop af
	retn

startup:
	ld sp,$FFFC
	im 1

	; Clear WRAM
	ld hl,WRAM_START
	ld de,WRAM_START+1
	ld bc,WRAM_END-WRAM_START-1
	ld (hl),0
	ldir

	; Silence YM2610
	call fm_stop
	call PA_reset
	call pb_stop
	call ssg_stop

	; Useless devkit port write (probably?)
	ld a,1
	out ($C0),a

	ld hl,98
	call ta_counter_load_set
	ld de,REG_TIMER_CNT<<8 | TM_CNT_LOAD_TA | TM_CNT_TA_FLG_RESET | TM_CNT_ENABLE_TA_IRQ
	rst RST_YM_WRITEA
	
	call set_default_banks

	out (ENABLE_NMI),a ; This does NOT crash or stop execution

main_loop:
	ei
	call UCOM_handle_command
	jr main_loop

fast_beep:
	push de
		ld de, 0040h	        ;Channel 1 frequency: 2kHz
		rst RST_YM_WRITEA
		ld de, 0100h
		rst RST_YM_WRITEA

		ld de, REG_SSG_VOL_ENV<<8 | $0F		;EG period: $50F
		rst RST_YM_WRITEA
		ld de, REG_SSG_COARSE_ENV<<8 | $05 
		rst RST_YM_WRITEA

		ld de, REG_SSG_CHA_VOL<<8 | $10		;Channel's 1 amplitude is tied to the EG
		rst RST_YM_WRITEA
		ld de, REG_SSG_VOL_ENV_SHAPE<<8 | $08		;EG shape: Repetitive ramp down
		rst RST_YM_WRITEA
		ld de, REG_SSG_MIX_ENABLE<<8 | $0E		;All channels except 1 are off
		rst RST_YM_WRITEA
	pop de
	ret

play_sample:
	push de
		ld de,REG_PA_MVOL<<8 | $3F
		rst RST_YM_WRITEB
		ld de,REG_PA_CVOL<<8 | %11000000 | $1F
		rst RST_YM_WRITEB
		ld de,REG_PA_STARTL<<8 | $00
		rst RST_YM_WRITEB
		ld de,REG_PA_STARTH<<8 | $00
		rst RST_YM_WRITEB
		ld de,REG_PA_ENDL<<8 | $40
		rst RST_YM_WRITEB
		ld de,REG_PA_ENDH<<8 | $00
		rst RST_YM_WRITEB
		ld de,REG_PA_CTRL<<8 | 1
		rst RST_YM_WRITEB
	pop de
	ret

set_default_banks:
	push af
		; Set $F000-$F7FF bank to bank $16 (30 *  2K; $F000~$F7FF)
		ld a,$1E
		in a,($08)
		; Set $E000-$EFFF bank to bank $0A (14 *  4K; $E000~$EFFF)
		ld a,$0E
		in a,($09)
		; Set $C000-$DFFF bank to bank $04 ( 6 *  8K; $C000~$DFFF)
		ld a,$06
		in a,($0A)
		; Set $8000-$BFFF bank to bank $02 ( 2 * 16K; $8000~$BFFF)
		ld a,$02
		in a,($0B)
	pop af
	ret

; Plays a noisy beep on the first FM channel
; and then enters an infinite loop
fm_softlock:
	di              
	call fm_stop

	; Set FM channel 1 registers
	ld d,REG_FM_CH13_FBLOCK
	ld e,$10
	rst RST_YM_WRITEA
	ld d,REG_FM_CH13_FNUM
	ld e,$FF
	rst RST_YM_WRITEA
	ld d,REG_FM_CH13_FBALGO
	ld e,$3F
	rst RST_YM_WRITEA
	ld d,REG_FM_CH13_LRAMSPMS
	ld e,%11000000
	rst RST_YM_WRITEA

	; Set operator 1
	ld d,REG_FM_CH1_OP1_DTMUL
	ld e,$00
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_TVOL
	ld e,$00
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_KSAR
	ld e,31
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_AMDR
	ld e,$00
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_SUSR
	ld e,$00
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_SLRR
	ld e,15
	rst RST_YM_WRITEA
	ld d,REG_FM_CH1_OP1_ENVGN
	ld e,0
	rst RST_YM_WRITEA

	ld d,REG_FM_KEY_ON
	ld e,$11
	rst RST_YM_WRITEA

	jp $

softlock:
	call ssg_stop

	ld d,REG_SSG_CHC_FINE_TUNE
	ld e,$FF
	rst RST_YM_WRITEA

	ld d,REG_SSG_CHC_COARSE_TUNE
	ld e,$05
	rst RST_YM_WRITEA

	ld d,REG_SSG_CHN_NOISE_TUNE
	ld e,$08
	rst RST_YM_WRITEA

	ld d,REG_SSG_CHN_NOISE_TUNE
	ld e,$08
	rst RST_YM_WRITEA

	ld d,REG_SSG_MIX_ENABLE
	ld e,%11011011
	rst RST_YM_WRITEA

	ld d,REG_SSG_CHC_VOL
	ld e,$0A
	rst RST_YM_WRITEA

	jp $

	include "rst.s"
port_write_delay1:
	ret

port_write_delay2:
	push bc     
	push de     
	push hl     
	pop  hl     
	pop  de     
	pop  bc
	ret

port_write_a:
	push af
		ld     a,d
		out    (YM2610_A0),a
		rst RST_YM_DELAY1
		;call port_write_delay1
		ld     a,e
		out    (YM2610_A1),a
		rst RST_YM_DELAY2
		;call port_write_delay2
	pop af
	ret

port_write_b:
	push af
		ld     a,d
		out    (YM2610_B0),a
		rst RST_YM_DELAY1
		;call port_write_delay1
		ld     a,e
		out    (YM2610_B1),a
		rst RST_YM_DELAY2
		;call port_write_delay2
	pop af
	ret

; [INPUT]
;	a: address
; [OUTPUT]
;	a: data
port_read_a:
	out    (YM2610_A0),a
	rst RST_YM_DELAY1
	;call port_write_delay1
	in    a,(YM2610_A1)
	rst RST_YM_DELAY2
	;call port_write_delay2
	ret
	include "com.s"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                 BIOS COMMANDS                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BCOM_prepare_switch:
	di			; Disable interrupts
    xor  a
    out  ($0C),a            ; Clear both buffers
    out  ($00),a
    ; Silence YM2610 here
    ld   sp,$FFFC           ; Reset SP
    ld   hl,stayinram
    push hl
    retn                    ; RETN to stayinram

stayinram:
    ld   hl,$FFFD
    ld   (hl),$C3	        ; (FFFD)=$C3, opcode for JP
    ld   ($FFFE),hl	        ; (FFFE)=$FFFD (makes "JP FFFD")
    ei
    ld   a,$01
    out  ($0C),a            ; Tell 68k that we're ready
    jp   $FFFD              ; Quickly jump to RAM loop

BCOM_reset:
	di			; Disable interrupts
	ld   sp,$FFFF		; Clear call stack
	ld   hl,0
	push hl
	retn			; RETN to 0

BCOM_bios10:
	ld sp,$fffc
	ld hl,$0e35
	push hl
	retn


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                 USER COMMANDS                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; a: byte
UCOM_write2buffer:
    push af
    push bc
    push hl
    push de
        ld b,a ; backup byte in b

        ; Calculate address to
        ; com_buffer[com_buffer_idx_w]
        ; and store it into hl
        ld hl,com_buffer
        ld a,(com_buffer_idx_w)
        and a,COM_BUFFER_LENGTH-1
        sla a  ; a *= 2
        ld d,0
        ld e,a
        add hl,de

        ; If the byte is the command word's MSB,
        ; then increment the address by one
        ld a,(com_buffer_byte_significance)
        and a,1 ; Wrap the byte significance inbetween 0 and 1
        ld e,a
        add hl,de

        ld (hl),b ; Store byte into buffer

        ; If the byte is the command word's MSB,
        ; then that means a command was fully 
        ; loaded. Proceed to increment com_buffer_idx_w
        ; by 1 (and wrap it around if it exceeds the
        ; buffer's maximum size)
        ld a,(com_buffer_idx_w)
        add a,e
        and a,COM_BUFFER_LENGTH-1
        ld (com_buffer_idx_w),a

        ; Flip the buffer byte significance
        ld a,e
        xor a,1
        ld (com_buffer_byte_significance),a
    pop de
    pop hl
    pop bc
    pop af
    ret

UCOM_handle_command:
    push af
    push bc
    push hl
        ; If the user communication buffers are equal,
        ; that means there are no new commands to run.
        ld a,(com_buffer_idx_w) ; $F841
        ld b,a
        ld a,(com_buffer_idx_r) ; $F842
        cp a,b 
        jr z,UCOM_handle_command_return

        ; Load command into bc, then
        ; parse and execute it.
        sla a  ; \
        ld c,a ; | bc = com_buffer_idx_r*2
        ld b,0 ; /
        ld hl,com_buffer
        add hl,bc
        ld c,(hl)
        inc hl
        ld b,(hl)

        call UCOM_run_command

        ; Set the current command
        ; word t$ $0080 (NOP)
        ld (hl),$00
        dec hl
        ld (hl),$80

        ; Increment com_buffer_idx_r
        srl a ; a /= 2
        inc a
        and a,COM_BUFFER_LENGTH-1
        ld (com_buffer_idx_r),a

UCOM_handle_command_return:
    pop hl
    pop bc
    pop af
    ret

; b: parameter
; c: command
UCOM_run_command:
    push af
    push bc
    push hl
    push de
        ; parameter &= UCOM_MASK (%01111111)
        ld a,b
        and a,UCOM_MASK
        ld b,a

        ; command &= UCOM_MASK (%01111111)
        ld a,c
        and a,UCOM_MASK
        ld c,a

        ; hl = &UCOM_command_vectors[command]
        sla a ; a *= 2
        ld e,a
        ld d,0
        ld hl,UCOM_command_vectors
        add hl,de

        ; hl *= hl; 
        ld e,(hl)
        inc hl
        ld d,(hl)
        ex de,hl

        jp (hl)

UCOM_run_command_return:
    pop de
    pop hl
    pop bc
    pop af
    ret

UCOM_command_vectors:
    dw UCOM_CMD_nop,       UCOM_CMD_play_song
    dw UCOM_CMD_stop_song, UCOM_CMD_ssg_test
    dup 124
        dw UCOM_CMD_invalid
    edup
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid
        dw UCOM_CMD_invalid

UCOM_CMD_nop:
    jp UCOM_run_command_return

; b: song
; c: $01
UCOM_CMD_play_song:
    call IRQ_write2buffer 
    jp UCOM_run_command_return

; b: $00
; c: $02
UCOM_CMD_stop_song:
    call IRQ_write2buffer
    jp UCOM_run_command_return

; b: $00
; c: $03
UCOM_CMD_ssg_test:
    jp UCOM_run_command_return

UCOM_CMD_invalid:
    call softlock
	include "ssg.s"
ssg_stop:
	push de
		ld de,REG_SSG_CHA_VOL<<8 | $00
		rst RST_YM_WRITEA
		ld de,REG_SSG_CHB_VOL<<8 | $00
		rst RST_YM_WRITEA
		ld de,REG_SSG_CHC_VOL<<8 | $00
		rst RST_YM_WRITEA

		ld de,REG_SSG_MIX_ENABLE<<8 | $3F
		rst RST_YM_WRITEA
	pop de
	ret

SSGCNT_init:
	push bc
	push af
	push de
	push hl
		; clear SSGCNT WRAM
		ld hl,SSGCNT_wram_start
		ld de,SSGCNT_wram_start+1
		ld bc,SSGCNT_wram_end-SSGCNT_wram_start-1
		ld (hl),0
		ldir

		ld b,3
SSGCNT_init_loop:
		ld a,b
		dec a

		; Set default volume
		ld c,15
		call SSGCNT_set_vol

		djnz SSGCNT_init_loop
	pop hl
	pop de
	pop af
	pop bc
	ret

; DOESN'T BACKUP REGISTERS!!
SSGCNT_irq:
	ld b,3

SSGCNT_irq_vol_loop:
	dec b
	call SSGCNT_update_volume
	call SSGCNT_update_note
	call SSGCNT_update_channels_mix
	inc b
	djnz SSGCNT_irq_vol_loop

	call SSGCNT_update_mixing
	call SSGCNT_update_noise_tune

	; Update all macros
	ld b,9                   ; total amount of macros
	ld de,ControlMacro.SIZE  ; de = sizeof(ControlMacro)
	ld ix,SSGCNT_macros
SSGCNT_irq_vol_macro_loop:
	call SSGCNT_MACRO_update
	add ix,de
	djnz SSGCNT_irq_vol_macro_loop

	ret

; b: channel (0~2)
SSGCNT_update_volume:
	push hl
	push de
	push af
	push bc
		; Load SSGCNT_channel_enable[ch]
		; in a
		ld hl,SSGCNT_channel_enable
		ld e,b
		ld d,0
		add hl,de
		ld a,(hl)

		; If channel enable is 0 (off) set 
		; volume to 0, else calculate the 
		; volume based on the channel volume
		; and the channel's volume macro, if enabled.
		ld c,0
		or a,a ; cp a,0
		call nz,SSGCNT_get_ym2610_ch_volume

		; Calculate the register address
		ld a,REG_SSG_CHA_VOL
		add a,b
		ld d,a
		ld e,c
		rst RST_YM_WRITEA
	pop bc
	pop af
	pop de
	pop hl
	ret

; [INPUT]
; 	b: channel (0~2)
; [OUTPUT]
;	c: volume
; Calculates the volume, based on the set 
; channel volume and also the channel's
; volume macro, if it's enabled
SSGCNT_get_ym2610_ch_volume:
	push hl
	push de
	push ix
	push af
		; Load SSGCNT_volumes[channel]
		; in c
		ld hl,SSGCNT_volumes
		ld e,b
		ld d,0
		add hl,de
		ld c,(hl)

		; Calculate pointer to the
		; channel's volume macro (ix)
		ld ixl,b
		ld ixh,0
		ld de,SSGCNT_vol_macro_A
		add ix,ix ; \
		add ix,ix ; | ix *= 8
		add ix,ix ; /
		add ix,de

		; If the macro is disabled (enable = $00)
		; then return, else calculate the volume
		; using the macro's data
		ld a,(ix+ControlMacro.enable)
		or a,a ; cp a,0
		jr z,SSGCNT_get_ym2610_ch_volume_return

		; Calculate pointer to current
		; volume array (a LUT is used to 
		; correctly set the volume of macros)
		ld l,c
		ld h,0
		add hl,hl ; -\
		add hl,hl ;   | hl *= 16
		add hl,hl ;  /
		add hl,hl ; /
		ld de,SSGCNT_vol_LUT
		add hl,de

		; Index said array to get the
		; desired volume
		call SSGCNT_NMACRO_read ; Load macro value in a
		ld e,a
		ld d,0
		add hl,de
		ld c,(hl)

SSGCNT_get_ym2610_ch_volume_return:
	pop af
	pop ix
	pop de
	pop hl
	ret

; b: channel (0~2)
SSGCNT_update_note:
	push hl
	push de
	push af
	push ix
		; Load SSGCNT_notes[channel]
		; into l
		ld hl,SSGCNT_notes
		ld e,b
		ld d,0
		add hl,de
		ld l,(hl)

		; Wrap l inbetween 0 and 127
		ld a,l
		and a,$7F
		ld l,a

		; Calculate pointer to
		; arpeggio macro
		ld ixl,b
		ld ixh,0
		ld de,SSGCNT_arp_macro_A
		add ix,ix ; \
		add ix,ix ; | ix *= 8
		add ix,ix ; /
		add ix,de

		; If the macro is disabled (enable = $00), 
		; just use the value in SSGCNT_notes[channel]
		xor a,a ; ld a,0
		cp a,(ix+ControlMacro.enable)
		jr z,SSGCNT_update_note_macro_disabled
		
		; Else (the macro is enabled) add to
		; the value in SSGCNT_notes[channel]
		; the macro's current value (signed addition)
		call SSGCNT_BMACRO_read ; Load macro value in a
		add a,l
		ld l,a

SSGCNT_update_note_macro_disabled:
		; Calculate pointer to
		; SSGCNT_note_LUT[note]
		ld h,0
		ld de,SSGCNT_note_LUT
		add hl,hl
		add hl,de

		; Load fine tune and write
		; it to correct register
		ld a,REG_SSG_CHA_FINE_TUNE
		add a,b ; - a += b*2
		add a,b ; /
		ld d,a
		ld e,(hl)
		rst RST_YM_WRITEA

		; Load coarse tune and write
		; it to the correct register
		inc d
		inc hl
		ld e,(hl)
		rst RST_YM_WRITEA
	pop ix
	pop af
	pop de
	pop hl
	ret

; b: channel (0~2)
;	Updates the channel's mixing according to the macros,
;   if the channel's mix macros are disabled this won't
;   do anything, and the mixing values set manually won't
;   be overwritten.
SSGCNT_update_channels_mix:
	push ix
	push de
	push af
	push bc
		; Load channel's mix macro enable in a
		ld ixl,b
		ld ixh,0
		ld de,SSGCNT_mix_macro_A
		add ix,ix ; \
		add ix,ix ; | hl *= 8
		add ix,ix ; /
		add ix,de
		ld a,(ix+ControlMacro.enable)

		; If the selected channel's mix macro is
		; disabled (enable == $00) then return
		or a,a ; cp a,0
		jr z,SSGCNT_update_mixing_macros_return

		call SSGCNT_NMACRO_read ; Stores macro value in a
		ld ixl,a ; backup macro value in ixl
		ld d,b   ; backup channel in d (channel parameter)

		; Enable tone if the mixing's byte
		; bit 0 is 1, else disable it
		and a,%00000001 ; Get tone enable bit
		ld c,a                    ; Enable/Disable parameter
		ld e,SSGCNT_MIX_EN_TUNE   ; Tune/Noise select parameter
		call SSGCNT_set_mixing

		; Enable noise if the mixing's byte
		; bit 1 is 1, else disable it
		ld a,ixl
		and a,%00000010 ; Get noise enable bit
		srl a
		ld c,a                   ; Enable/Disable parameter
		ld e,SSGCNT_MIX_EN_NOISE ; Tune/Noise select parameter
		call SSGCNT_set_mixing

SSGCNT_update_mixing_macros_return:
	pop bc
	pop af
	pop de
	pop ix
	ret

; This just flips the SSGCNT_mix_flags byte and
; sets the YM2610's registers accordingly
SSGCNT_update_mixing:
	push de
	push af
		ld d,REG_SSG_MIX_ENABLE
		ld a,(SSGCNT_mix_flags)
		xor a,$3F ; Flip all flags, since the SSG mixing register uses negative enable flags
		ld e,a
		rst RST_YM_WRITEA
	pop af
	pop de
	ret

SSGCNT_update_noise_tune:
	push de
	push af
		ld d,REG_SSG_CHN_NOISE_TUNE
		ld a,(SSGCNT_noise_tune)
		ld e,a
		rst RST_YM_WRITEA
	pop af
	pop de
	ret

; a: channel
; c: volume
SSGCNT_set_vol:
	push bc
	push hl
	push af
		ld b,a ; \
		ld a,c ; | Swap a and c
		ld c,b ; /

		ld b,0
		ld hl,SSGCNT_volumes
		add hl,bc
		ld (hl),a
	pop af
	pop hl
	pop bc
	ret

; a: noise tune
; 	Everyone needs a useless
;	subroutine that is there
;	only for consistency!
SSGCNT_set_noise_tune:
	ld (SSGCNT_noise_tune),a
	ret

; a: channel
; c: note
SSGCNT_set_note:
	push bc
	push hl
	push af
		ld b,a ; \
		ld a,c ; | Swap a and c
		ld c,b ; /

		ld b,0
		ld hl,SSGCNT_notes
		add hl,bc
		ld (hl),a
	pop af
	pop hl
	pop bc
	ret

; e: flag type to set/clear (SSGCNT_MIX_EN_TUNE = 0; SSGCNT_MIX_EN_NOISE = 3)
; d: SSG channel (0~2)
; c: 0 if the flag needs to be cleared, 1 if the flag needs to be set
; POSITIVE ENABLE!
SSGCNT_set_mixing:
	push af
	push bc
	push hl
	push de
		; bit <<= ssg_channel + flag_type
		ld a,e
		add a,d
		ld b,a
		call shift_left_c_by_b_bits ; Clears b
		ld a,e   ; \
		add a,d  ; | Calculate b again
		ld b,a   ; /
		ld e,c ; backup bit in e

		; Calculate mask
		;	mask = 1 << (ssg_channel + flag_type)
		ld c,1
		call shift_left_c_by_b_bits

		; mix_flags = ~mask $ SSGCNT_mix_flags
		ld hl,SSGCNT_mix_flags
		ld a,c
		xor a,$FF
		and a,(hl)

		; mix_flags |= bit
		or a,e
		ld (hl),a
	pop de
	pop hl
	pop bc
	pop af
	ret

; a: channel
SSGCNT_enable_channel:
	push hl
	push de
		ld hl,SSGCNT_channel_enable
		ld e,a
		ld d,0
		add hl,de
		ld (hl),$FF
	pop de
	pop hl
	ret

; a: channel
SSGCNT_disable_channel:
	push hl
	push de
		ld hl,SSGCNT_channel_enable
		ld e,a
		ld d,0
		add hl,de
		ld (hl),0
	pop de
	pop hl
	ret

; [INPUT]
; 	ix: pointer to macro
; [OUTPUT]
;	a:  Current macro value
; CHANGES FLAGS!!
SSGCNT_BMACRO_read:
	push hl
	push de
		; a = macro.data[macro.curr_pt]
		ld l,(ix+ControlMacro.data)
		ld h,(ix+ControlMacro.data+1)
		ld e,(ix+ControlMacro.curr_pt)
		ld d,0
		add hl,de
		ld a,(hl)
	pop de
	pop hl
	ret

; [INPUT]
; 	ix: pointer to macro
; [OUTPUT]
;	a:  Current macro value
; CHANGES FLAGS!!
SSGCNT_NMACRO_read:
	push hl
	push de
		; Load byte containing the value
		; by adding to the macro data 
		; pointer curr_pt divided by two
		ld l,(ix+ControlMacro.data)
		ld h,(ix+ControlMacro.data+1)
		ld a,(ix+ControlMacro.curr_pt)
		srl a
		ld e,a ; e = macro.curr_pt / 2
		ld d,0
		add hl,de
		ld a,(hl)

		; If macro.curr_pt is even, then
		; return the least significant nibble,
		; else return the most significant one.
		bit 0,(ix+ControlMacro.curr_pt)
		jr z,SSGCNT_NMACRO_read_even_pt

		srl a ; \
		srl a ;  | a >>= 4
		srl a ;  | (VVVV---- => 0000VVVV)
		srl a ; /

SSGCNT_NMACRO_read_even_pt:
		and a,$0F
	pop de
	pop hl
	ret

; ix: pointer to macro
SSGCNT_MACRO_update:
	push af
		; If macro.loop_pt is bigger or equal 
		; than the actual length, set it to
		; the length minus 1 (remember that
		; the length is always stored 
		; decremented by one)
		ld a,(ix+ControlMacro.length)
		cp a,(ix+ControlMacro.loop_pt)
		jr nc,SSGCNT_MACRO_update_valid_loop_pt ; if macro.length >= macro.loop_pt ...

		ld (ix+ControlMacro.loop_pt),a ; macro.loop_pt = macro.length (length is stored decremented by 1)
SSGCNT_MACRO_update_valid_loop_pt:

		; increment macro.curr_pt, if it
		; overflows set it to macro.loop_pt
		inc (ix+ControlMacro.curr_pt)
		cp a,(ix+ControlMacro.curr_pt)
		jr nc,SSGCNT_MACRO_update_return ; if macro.length >= macro.curr_pt

		ld a,(ix+ControlMacro.loop_pt)
		ld (ix+ControlMacro.curr_pt),a

SSGCNT_MACRO_update_return:
	pop af
	ret

; ix: pointer to macro
; hl: pointer to macro initialization data
;    if hl is equal to MLM_HEADER, 
;    the macro will NOT be set
SSGCNT_MACRO_set:
	push af
	push hl
	push de
		; Disable macro, if needed it'll be 
		; enabled later in the function
		ld (ix+ControlMacro.enable),$00

		; If the address to the macro initialization data is
		; equal to MLM_HEADER, then return from the subroutine
		;   if address is equal to offset + MLM_HEADER; then
		;   when the offset will be 0 the address will be MLM_HEADER
		push hl
		ld de,MLM_HEADER
		or a,a    ; Clear carry flag
		sbc hl,de ; cp hl,de
		pop hl
		jr z,SSGCNT_MACRO_set_return

		; Set macro's length
		ld a,(hl)
		ld (ix+ControlMacro.length),a

		; Set macro's loop point
		inc hl
		ld a,(hl)
		ld (ix+ControlMacro.loop_pt),a

		; Set macro's data pointer
		inc hl
		ld (ix+ControlMacro.data),l
		ld (ix+ControlMacro.data+1),h

		; Set other variables
		ld (ix+ControlMacro.enable),$FF
		ld (ix+ControlMacro.curr_pt),0
SSGCNT_MACRO_set_return:
	pop de
	pop hl
	pop af
	ret

; a: channel
;  Starts's all channel's macros
SSGCNT_start_channel_macros:
	push ix
	push de
		; Calculate address to channel's mix macro,
		; and set mix_macro.curr_pt to 0
		ld ixl,a
		ld ixh,0
		ld de,SSGCNT_mix_macro_A
		add ix,ix ; \
		add ix,ix ; | ix *= 8
		add ix,ix ; /
		add ix,de
		ld (ix+ControlMacro.curr_pt),0

		; Set channel's volume macro.curr_pt to 0
		ld de,ControlMacro.SIZE*3
		add ix,de
		ld (ix+ControlMacro.curr_pt),0
		
		; Set channel's arpeggio macro.curr_pt to 0
		add ix,de
		ld (ix+ControlMacro.curr_pt),0
	pop de
	pop ix
	ret

; ==== LOOKUP TABLES ====
SSGCNT_note_LUT:
	incbin "ssg_pitch_lut.bin"

SSGCNT_vol_LUT:
	incbin "ssg_vol_lut.bin"
	
	include "adpcm.s"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                 ADPCM-A                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PA_stop:
	push de
		ld de,REG_PA_CTRL<<8 | $BF
		rst RST_YM_WRITEB
	pop de
	ret

PA_reset:
	push de
	push bc
	push af
		call PA_stop

		; Set volumes to $1F and panning
		; to center for every channel
		ld b,6
		ld d,REG_PA_CVOL
		ld e,PANNING_CENTER | $1F
PA_reset_loop:
		rst RST_YM_WRITEB
		inc d
		djnz PA_reset_loop

		; Set master volume to $3F
		ld de,REG_PA_MVOL<<8 | $3F
		rst RST_YM_WRITEB
	pop af
	pop bc
	pop de
	ret
; a:  channel (0: ADPCM-A 1, ..., 5: ADPCM-A 6)
; ix: source (smp start LSB; smp start MSB; smp end LSB; smp start MSB)
PA_set_sample_addr:
	push af
	push de
		ld d,REG_PA_STARTL
		add a,d
		ld d,a
		ld e,(ix+0)
		rst RST_YM_WRITEB

		add a,REG_PA_STARTH-REG_PA_STARTL
		ld d,a
		ld e,(ix+1)
		rst RST_YM_WRITEB

		add a,REG_PA_ENDL-REG_PA_STARTH
		ld d,a
		ld e,(ix+2)
		rst RST_YM_WRITEB

		add a,REG_PA_ENDH-REG_PA_ENDL
		ld d,a
		ld e,(ix+3)
		rst RST_YM_WRITEB
	pop de
	pop af
	ret

; c: channel
PA_stop_sample:
	push hl
	push bc
	push af
	push de
		ld hl,PA_channel_on_masks
		ld b,0
		add hl,bc
		ld e,(hl)

		set 7,e   ; Set dump bit
		ld d,REG_PA_CTRL
		rst RST_YM_WRITEB
	pop de		
	pop af
	pop bc
	pop hl
	ret

; a: channel
; c: volume
PA_set_channel_volume:
	push de
	push hl
		; Store volume in 
		; PA_channel_volumes[channel]
		ld h,0
		ld l,a
		ld de,PA_channel_volumes
		add hl,de
		ld (hl),c

		; Load panning from 
		; PA_channel_pannings[channel]
		; and OR it with the volume
		push af
			ld h,0
			ld l,a
			ld de,PA_channel_pannings
			add hl,de
			ld e,(hl)
			ld a,c
			or a,e ; ORs the volume and panning
			ld e,a
		pop af

		; Set CVOL register
		push af
			add a,REG_PA_CVOL
			ld d,a
		pop af
		rst RST_YM_WRITEB
	pop hl
	pop de
	ret

; a: channel
; c: panning (0: none, 64: right, 128: left, 192: both)
PA_set_channel_panning:
	push hl
	push de
	push bc
		; Store panning in 
		; PA_channel_pannings[channel]
		ld h,0
		ld l,a
		ld de,PA_channel_pannings
		add hl,de
		ld (hl),c

		; Load volume from
		; MLM_channel_volumes[channel]
		; and OR it with the panning
		push af
			ld h,0
			ld l,a
			ld de,PA_channel_volumes
			add hl,de
			ld a,(hl)
			or a,c
			ld e,a
		pop af

		; Set CVOL register
		push af
			add a,REG_PA_CVOL
			ld d,a
		pop af
		rst RST_YM_WRITEB
	pop bc
	pop de
	pop hl
	ret

PA_channel_on_masks:
	db %00000001,%00000010,%00000100,%00001000,%00010000,%00100000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                 ADPCM-B                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pb_stop:
	push de
		ld de,REG_PB_CTRL<<8 | $01
		rst RST_YM_WRITEB

		dec e
		rst RST_YM_WRITEB
	pop de
	ret
	include "fm.s"
fm_stop:
	push de
		ld de,REG_FM_KEY_ON<<8 | FM_CH1
		rst RST_YM_WRITEA
		ld e,FM_CH2
		rst RST_YM_WRITEA
		ld e,FM_CH3
		rst RST_YM_WRITEA
		ld e,FM_CH4
		rst RST_YM_WRITEA
	pop de
	ret

FMCNT_init:
	push hl
	push de
	push bc
	push af
		call fm_stop

		; clear FM WRAM
		ld hl,FM_wram_start
		ld de,FM_wram_start+1
		ld bc,FM_wram_end-FM_wram_start-1
		ld (hl),0
		ldir

		; set all operator TLs to $7F
		ld hl,FM_operator_TLs
		ld de,FM_operator_TLs+1
		ld bc,FM_CHANNEL_COUNT*FM_OP_COUNT - 1
		ld (hl),$7F
		ldir
		
		ld b,4

FMCNT_init_loop:
		ld c,b
		dec c
		ld a,$7F ; default volume
		call FMCNT_set_volume

		ld a,PANNING_CENTER
		call FMCNT_set_panning
		djnz FMCNT_init_loop
	pop af
	pop bc
	pop de
	pop hl
	ret

; DOESN'T BACKUP REGISTERS !!!
FMCNT_irq:
	;ret
	ld b,FM_CHANNEL_COUNT
FMCNT_irq_loop:
	; If FM_channel_enable[channel] is 0,
	; then continue to the next channel
	ld hl,FM_channel_enable-1
	ld e,b
	ld d,0
	add hl,de
	ld a,(hl)
	or a,a ; cp a,0
	jr z,FMCNT_irq_loop_continue

	call FMCNT_update_frequencies
	call FMCNT_update_total_levels
	call FMCNT_update_key_on

FMCNT_irq_loop_continue:
	djnz FMCNT_irq_loop
	ret

; b: channel (1~4)
FMCNT_update_frequencies:
	push de
	push hl
	push bc
	push af		
		; Calculate address to
		; FM_channel_frequencies[channel]+1
		dec b
		ld l,b
		ld h,0
		ld de,FM_channel_frequencies+1
		add hl,hl
		add hl,de

		; Set Block and F-Num 2
		ld e,(hl)
		ld d,REG_FM_CH13_FBLOCK
		bit 0,b
		jr z,FMCNT_update_frequencies_even_ch
		inc d
FMCNT_update_frequencies_even_ch:
		; If the channel is 0 and 1,
		; use port A, else (channel
		; is 2 and 3) use port B
		bit 1,b
		call z,port_write_a
		call nz,port_write_b

		; Set F-Num 1
		dec hl
		ld e,(hl)
		dec d ; -\
		dec d ;  | d -= 4
		dec d ;  /
		dec d ; /
		bit 1,b
		call z,port_write_a
		call nz,port_write_b
	pop af
	pop bc
	pop hl
	pop de
	ret

; b: channel (1~4)
FMCNT_update_total_levels:
	push bc
	push hl
	push de
	push af
		; Load channel algorithm in e
		ld hl,FM_channel_algos-1
		ld e,b
		ld d,0
		add hl,de
		ld e,(hl)

		; Calculate address to the
		; correct FMCNT_optype_LUT entry
		ld hl,FMCNT_optype_LUT
		add hl,de
		add hl,de 
		add hl,de 
		add hl,de

		xor a,a ; ld a,0
		ld c,b
		dec c
		ld b,FM_OP_COUNT

		; Depending on the FMCNT_optype_LUT 
		; entry, either modify the op TL
		; based on the channel volume or don't.
FMCNT_update_total_levels_loop:
		cp a,(hl)
		call z,FMCNT_update_modulator_tl
		call nz,FMCNT_update_carrier_tl
		inc hl
		djnz FMCNT_update_total_levels_loop
	pop af
	pop de
	pop hl
	pop bc
	ret

; Specifies whether or not the operator is
; a carrier (1) or a modulator (0).
; The order is OP4, OP3, OP2, OP1.
FMCNT_optype_LUT:
	db 1, 0, 0, 0 ; Algorithm 0
	db 1, 0, 0, 0 ; Algorithm 1
	db 1, 0, 0, 0 ; Algorithm 2
	db 1, 0, 0, 0 ; Algorithm 3
	db 1, 0, 1, 0 ; Algorithm 4
	db 1, 1, 1, 0 ; Algorithm 5
	db 1, 1, 1, 0 ; Algorithm 6
	db 1, 1, 1, 1 ; Algorithm 7

; b: operator (1~4)
; c: channel (0~3)
;	This calculates the Total Level
;   relative to the channel volume,
;   and then sets the register based
;   on the result of said calculation.
FMCNT_update_carrier_tl:
	push hl
	push de
	push af
		; Load current op's TL from WRAM
		; into a, then invert its least
		; significant 7 bits
		ld h,0
		ld l,c
		ld de,FM_operator_TLs-1 ; Operator indexing starts from 1 instead than 0
		add hl,hl               ; - hl *= 4
		add hl,hl               ; /
		add hl,de               ; calculate address to FM_operator_TLs[channel]-1
		ld e,b
		ld d,0
		add hl,de               ; calculate address to FM_operator_TLs[channel][operator]
		ld a,(hl)
		xor a,$7F               ; lowest 127 highest 0 -> lowest 0 highest 127

		; Load volume from WRAM into e
		ld l,c
		ld h,0
		ld de,FM_channel_volumes
		add hl,de
		ld e,(hl)

		; Multiply the op TL by the volume,
		; store it into hl, then divide it by 127.
		; The result will be stored in hl, but h
		; should be always equal to zero. 
		push bc
			ld h,a
			call H_Times_E
			ld c,127
			call RoundHL_Div_C
		pop bc

		; Invert the result's least 
		; significant 7 bits
		ld a,l
		xor a,$7F

		; Load OP register offset in d
		ld h,0
		ld l,b
		ld de,FM_op_register_offsets_LUT-1
		add hl,de
		ld d,(hl)

		; If channel is odd (1 and 3) 
		; add 1 to register offset.
		; Finally, proceed to add
		; TL register address ($41)
		ld e,a ; Move TL in E
		ld a,c
		and a,1
		add a,d
		add a,REG_FM_CH1_OP1_TVOL
		ld d,a

		; If the channel is 0 and 1 write 
		; to port a, else write to port b
		bit 1,c              
		call z,port_write_a  
		call nz,port_write_b 
	pop af
	pop de
	pop hl
	ret

; b: operator (1~4)
; c: channel (0~3)
;	This just sets the operator's
;   Total Level without modifying it.
FMCNT_update_modulator_tl:
	push hl
	push de
	push af
		; Load current op's TL from WRAM into a
		ld h,0
		ld l,c
		ld de,FM_operator_TLs-1 ; Operator indexing starts from 1 instead than 0
		add hl,hl               ; - hl *= 4
		add hl,hl               ; /
		add hl,de               ; calculate address to FM_operator_TLs[channel]-1
		ld e,b
		ld d,0
		add hl,de               ; calculate address to FM_operator_TLs[channel][operator]
		ld a,(hl)

		; Load OP register offset in d
		ld h,0
		ld l,b
		ld de,FM_op_register_offsets_LUT-1
		add hl,de
		ld d,(hl)

		; If channel is odd (1 and 3) 
		; add 1 to register offset.
		; Finally, proceed to add
		; TL register address ($41)
		ld e,a ; Move TL in E
		ld a,c
		and a,1
		add a,d
		add a,REG_FM_CH1_OP1_TVOL
		ld d,a

		; If the channel is 0 and 1 write 
		; to port a, else write to port b
		bit 1,c              
		call z,port_write_a  
		call nz,port_write_b 
	pop af
	pop de
	pop hl
	ret

FM_op_register_offsets_LUT:
	db $00,$08,$04,$0C

; b: channel (1~4)
FMCNT_update_key_on:
	push hl
	push de
	push af
		; Load channel's key on enable
		; from WRAM, then clear it
		ld hl,FM_channel_key_on-1
		ld e,b
		ld d,0
		add hl,de
		ld e,(hl)
		xor a,a ; ld a,0
		ld (hl),a

		; If the value is 0, then don't
		; write to the key on register
		ld a,e
		or a,a ; cp a,0
		jr z,FMCNT_update_key_on_ret

		; Else, do write to the key on register.
		; Load OP enable from WRAM in a
		ld hl,FM_channel_op_enable-1
		ld e,b
		add hl,de
		ld a,(hl)
		and a,$F0 ; Clear the lower nibble just in case

		; Calculate address to correct FM channel id
		ld hl,FM_channel_LUT-1
		add hl,de

		; Proceed to stop the FM channel
		ld e,(hl)
		ld d,REG_FM_KEY_ON
		rst RST_YM_WRITEA
		
		; OR the FM channel id and the OP enable 
		; nibble, then store the result in e and
		; write it to the FM Key On YM2610 register
		or a,(hl)
		ld e,a
		ld d,REG_FM_KEY_ON
		rst RST_YM_WRITEA

FMCNT_update_key_on_ret:
	pop af
	pop de
	pop hl
	ret

; a: fbalgo (--FFFAAA; Feedback, Algorithm)
; c: channel (0~3)
FMCNT_set_fbalgo:
	push de
	push af
	push hl
		call FMCNT_assert_channel
		ld e,a ; Store value in e

		; If the channel is even then
		; use register $B1, else use $B2
		ld d,REG_FM_CH13_FBALGO
		bit 0,c
		jr z,FMCNT_set_fbalgo_even_ch
		inc d

FMCNT_set_fbalgo_even_ch:
		; If the channel is 0 and 1,
		; use port A, else (channel
		; is 2 and 3) use port B
		bit 1,c
		call z,port_write_a
		call nz,port_write_b

		; Store algorithm in WRAM
		and a,%00000111 ; --FFFAAA -> 00000AAA
		ld hl,FM_channel_algos
		ld e,c
		ld d,0
		add hl,de
		ld (hl),a
	pop hl
	pop af
	pop de
	ret

; a: amspms (--AA-PPP; Ams, Pms)
; c: channel (0~3)
FMCNT_set_amspms:
	push de
	push af
	push hl
		call FMCNT_assert_channel

		; Load channel's Panning, 
		; AMS and PMS from WRAM
		ld hl,FM_channel_lramspms
		ld e,c
		ld d,0
		add hl,de

		; Clear channel's AMS and PMS,
		; And OR the desired AMS and PMS.
		; then load OR result in e
		ld e,a
		ld a,(hl)
		and a,%11001000 ; LR??-??? -> LR00-000
		or a,e          ; LR00-000 -> LRAA-PPP
		ld (hl),a       ; Store register value in WRAM
		ld e,a

		; If the channel is even then
		; use register $B1, else use $B2
		ld d,REG_FM_CH13_LRAMSPMS
		bit 0,c
		jr z,FMCNT_set_amspms_even_ch
		inc d

FMCNT_set_amspms_even_ch:
		; If the channel is 0 and 1,
		; use port A, else (channel
		; is 2 and 3) use port B
		bit 1,c
		call z,port_write_a
		call nz,port_write_b
	pop hl
	pop af
	pop de
	ret

; a: panning (LR------; Left and Right)
; c: channel (0~3)
FMCNT_set_panning:
	push de
	push af
	push hl
		call FMCNT_assert_channel

		; Load channel's Panning, 
		; AMS and PMS from WRAM
		ld hl,FM_channel_lramspms
		ld e,c
		ld d,0
		add hl,de

		; Clear channel's AMS and PMS,
		; And OR the desired AMS and PMS
		ld e,a
		ld a,(hl)
		and a,%00111111 ; ??AA-PPP -> 00AA-PPP
		or a,e          ; 00AA-PPP -> LRAA-PPP
		ld (hl),a       ; Store register value in WRAM

		; If the channel is even then
		; use register $B1, else use $B2
		ld d,REG_FM_CH13_LRAMSPMS
		bit 0,c
		jr z,FMCNT_set_panning_even_ch
		inc d

FMCNT_set_panning_even_ch:
		; If the channel is 0 and 1,
		; use port A, else (channel
		; is 2 and 3) use port B
		bit 1,c
		call z,port_write_a
		call nz,port_write_b
	pop hl
	pop af
	pop de
	ret

; hl: pointer to operator data
; c:  channel (0~3)
; b:  operator (0~3)
FMCNT_set_operator:
	push hl
	push de
	push af
	push bc
		call FMCNT_assert_channel
		call FMCNT_assert_operator

		; Load OP register offset in a, then 
		; add said offset to DTMUL base address.
		; After that, move result to d
		push hl
			ld h,0
			ld l,b
			ld de,FM_op_register_offsets_LUT
			add hl,de
			ld a,(hl)
			add a,REG_FM_CH1_OP1_DTMUL
			ld d,a
		pop hl

		; If channel is odd (1 and 3) 
		; increment register address.
		ld a,c
		and a,1
		add a,d
		ld d,a

		; Set DT and MUL
		ld e,(hl)
		bit 1,c              ; \
		call z,port_write_a  ; | If the channel is 0 and 1 use port a else use port b
		call nz,port_write_b ; /
		inc hl               ; increment pointer to source
		ld a,$10             ; \
		add a,d              ; | Increment register address
		ld d,a               ; /

		; Store TL in WRAM
		push hl
		push de
			; Calculate address to FM_operator_TLs[channel][0]
			ld a,c
			sla a ; - a *= 4
			sla a ; /
			ld e,a
			ld d,0
			ld a,(hl) ; Store TL in a
			ld hl,FM_operator_TLs
			add hl,de

			; Calculate address to 
			; FM_operator_TLs[channel][operator],
			; then store TL in said address
			ld e,b
			ld d,0
			add hl,de
			ld (hl),a
		pop de
		pop hl
		inc hl   ; increment pointer to source
		ld a,$10 ; \
		add a,d  ; | Increment register address
		ld d,a   ; /

		; Set the operator registers
		ld b,5 ; operator registers left count
FMCNT_set_operator_loop:
		ld e,(hl)
		bit 1,c              ; \
		call z,port_write_a  ; | If the channel is 0 and 1 use port a else use port b
		call nz,port_write_b ; /

		; Increment pointer to source and register address
		inc hl
		ld a,$10
		add a,d
		ld d,a

		djnz FMCNT_set_operator_loop
	pop bc
	pop af
	pop de
	pop hl
	ret

; a: operator enable (4321----; op 4 enable; op 3 enable; op 2 enable; op 1 enable)
; c: channel (0~3)
FMCNT_set_op_enable:
	push hl
	push bc
	push af
		call FMCNT_assert_channel

		; Store OP enable in WRAM
		ld hl,FM_channel_op_enable
		ld b,0
		add hl,bc
		ld (hl),a
	pop af
	pop bc
	pop hl
	ret

; ixh: note (-OOONNNN; Octave, Note)
; ixl: channel
FMCNT_set_note:
	push hl
	push de
	push af
	push bc
		ld c,ixl
		call FMCNT_assert_channel

		; Load base pitch from FMCNT_pitch_LUT in bc
		ld a,ixh
		and a,$0F ; -OOONNNN -> 0000NNNN; Get note
		ld l,a
		ld h,0
		ld de,FMCNT_pitch_LUT
		add hl,hl
		add hl,de
		ld c,(hl)
		inc hl
		ld b,(hl)

		; Set block/octave
		ld a,ixh
		and a,%01110000 ; Get octave (-OOONNNN -> 0OOO0000)
		add a,%00010000 ; Increment octave by 1
		srl a           ; Get octave in the right position (block needs to be set to octave)
		or a,b          ; OR block with F-Num 2
		ld b,a

		; Store bc in WRAM
		ld h,0
		ld e,ixl
		ld l,e
		ld de,FM_channel_frequencies
		add hl,hl
		add hl,de
		ld (hl),c
		inc hl
		ld (hl),b
	pop bc
	pop af
	pop de
	pop hl
	ret

; to set the octave you just need to set "block".
; octave 0 = block 1, etc...
; If the note number exceeds the valid maximum, play a B
FMCNT_pitch_LUT:
	;  C    C#   D    D#   E    F    F#   G
	dw 309, 327, 346, 367, 389, 412, 436, 462
	;  G#   A    A#   B
 	dw 490, 519, 550, 583, 583, 583, 583, 583

; a: volume (0 is lowest, 127 is highest)
; c: channel (0~3)
FMCNT_set_volume:
	push hl
	push bc
	push af
		call FMCNT_assert_channel

		ld b,0
		ld hl,FM_channel_volumes
		add hl,bc
		and a,127 ; Wrap volume inbetween 0 and 127
		ld (hl),a
	pop af
	pop bc
	pop hl
	ret

; c: channel
FMCNT_play_channel:
	push af
	push bc
	push hl
		call FMCNT_assert_channel

		ld hl,FM_channel_key_on
		ld b,0
		add hl,bc
		ld a,$FF
		ld (hl),a
	pop hl
	pop bc
	pop af
	ret

; c: channel
FMCNT_stop_channel:
	push af
	push de
	push hl
		call FMCNT_assert_channel

		; Clear channel's key on value in WRAM
		ld hl,FM_channel_key_on
		ld e,c
		ld d,0
		add hl,de
		xor a,a ; ld a,0
		ld (hl),a

		; Calculate address to correct FM channel id
		ld hl,FM_channel_LUT
		add hl,de

		; Load the FM channel id in e and
		; write it to the FM Key On YM2610 
		; register (OP enable is all cleared)
		ld e,(hl)
		ld d,REG_FM_KEY_ON
		rst RST_YM_WRITEA
	pop hl
	pop de
	pop af
	ret

; c: channel (0~3)
FM_enable_channel:
	push af
	push bc
	push hl
		ld b,0
		ld hl,FM_channel_enable
		add hl,bc
		ld (hl),$FF
	pop hl
	pop bc
	pop af
	ret

; c: channel (0~3)
FM_disable_channel:
	push af
	push bc
	push hl
		ld b,0
		ld hl,FM_channel_enable
		add hl,bc
		ld (hl),$00
	pop hl
	pop bc
	pop af
	ret

FM_channel_LUT:
	db FM_CH1, FM_CH2, FM_CH3, FM_CH4

; c: channel
;	if the channel is invalid (> 3),
;   softlock the program 
FMCNT_assert_channel:
	push af
		ld a,c
		cp a,4 
		jp nc,softlock ; if a >= 4 then softlock
	pop af
	ret

; b: channel
;	if the operator is invalid (> 3),
;   softlock the program 
FMCNT_assert_operator:
	push af
		ld a,b
		cp a,4 
		jp nc,softlock ; if a >= 4 then softlock
	pop af
	ret
	include "timer.s"
; hl: counter load (%------TTTTTTTTTT) 
ta_counter_load_set:
	push hl
	push de
	push af
		; Set Timer A counter load LSB
		ld d,REG_TMA_COUNTER_LSB
		ld a,l
		and a,%00000011
		ld e,a
		rst RST_YM_WRITEA

		srl_hl
		srl h
		rr l
		srl_hl
		srl h
		rr l
		dec d
		ld e,l
		rst RST_YM_WRITEA
	pop af
	pop de
	pop hl
	ret
	include "mlm.s"
; DOESN'T BACKUP REGISTERS
MLM_irq:
	ld iyl,0 ; Clear active mlm channel counter

	; base time counter code
	ld a,(MLM_base_time)
	ld c,a
	ld a,(MLM_base_time_counter)	
	inc a
	cp a,c
	ld (MLM_base_time_counter),a
	jr nz,MLM_update_skip

	ld b,CHANNEL_COUNT
MLM_update_loop:
	ld c,b
	dec c

	call MLM_update_channel_playback
	call MLM_update_channel_volume

	djnz MLM_update_loop 

	; Clear MLM_base_time_counter
	xor a,a
	ld (MLM_base_time_counter),a

	; if active mlm channel counter is 0,
	; then all channels have stopped, proceed
	; to call MLM_stop
	ld a,iyl
	or a,a ; cp a,0
	call z,MLM_stop

MLM_update_skip:
	ret

; [INPUT]
; 	c: channel
; [OUTPUT]
;	iyl: active channel count 
MLM_update_channel_playback:
	push hl
	push de
	push af
		; if MLM_playback_control[ch] == 0 then
		; do not update this channel
		ld h,0
		ld l,c
		ld de,MLM_playback_control
		add hl,de
		ld a,(hl)
		or a,a ; cp a,0
		jr z,MLM_update_channel_playback_ret

		inc iyl ; increment active mlm channel counter

		; hl = $MLM_playback_timings[channel]
		; de = *hl
		ld h,0
		ld l,c
		ld de,MLM_playback_timings
		add hl,hl
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)

		; Decrement the timing and 
		; store it back into WRAM
		dec de 
		ld (hl),d
		dec hl
		ld (hl),e

		; if timing==0 update events
		; else save decremented timing
		push hl
			ld hl,0
			or a,a ; clear carry flag
			sbc hl,de
		pop hl
MLM_update_channel_playback_execute_events:
		call z,MLM_update_events

		; if MLM_playback_set_timings[ch] is 0
		; (thus the timing was set to 0 during this loop)
		; then execute the next event immediately
		ld h,0
		ld l,c
		ld de,MLM_playback_set_timings
		add hl,hl
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)

		; compare de to 0
		push hl
			ld hl,0
			or a,a ; clear carry flag
			sbc hl,de
		pop hl
		jr z,MLM_update_channel_playback_execute_events
MLM_update_channel_playback_ret:
	pop af
	pop de
	pop hl
	ret

; c: channel
MLM_update_channel_volume:
	push bc
	push hl
	push af
	push de
		ld b,0
		ld hl,MLM_channel_volumes
		add hl,bc
		ld a,(hl)

		ld h,0
		ld l,c
		ld de,MLM_update_ch_vol_vectors
		add hl,hl
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		jp (hl)
MLM_update_ch_vol_return:
	pop de
	pop af
	pop hl
	pop bc
	ret

MLM_update_ch_vol_vectors:
	dw MLM_update_ch_vol_PA,MLM_update_ch_vol_PA
	dw MLM_update_ch_vol_PA,MLM_update_ch_vol_PA
	dw MLM_update_ch_vol_PA,MLM_update_ch_vol_PA
	dw MLM_update_ch_vol_FM,MLM_update_ch_vol_FM
	dw MLM_update_ch_vol_FM,MLM_update_ch_vol_FM
	dw MLM_update_ch_vol_SSG,MLM_update_ch_vol_SSG
	dw MLM_update_ch_vol_SSG

MLM_update_ch_vol_PA:
	push af
	push bc
		; Scale down volume
		; ($00~$FF -> $00~$1F)
		srl a
		srl a
		srl a

		; swap a and c
		ld b,c
		ld c,a
		ld a,b

		call PA_set_channel_volume
	pop bc
	pop af
	jr MLM_update_ch_vol_return

MLM_update_ch_vol_FM:
	push af
		; Scale down volume ($00~$FF -> $00 $7F)
		srl a

		; Calculate Fm channel (0~3)
		push af
			ld a,c
			sub a,MLM_CH_FM1
			ld c,a
		pop af
		call FMCNT_set_volume
	pop af
	jr MLM_update_ch_vol_return

MLM_update_ch_vol_SSG:
	push af
	push bc
		; Scale down volume
		; ($00~$FF -> $00~$0F)
		srl a
		srl a
		srl a
		srl a

		; swap a and c
		ld b,c
		ld c,a
		ld a,b

		sub a,MLM_CH_SSG1
		call SSGCNT_set_vol
	pop bc
	pop af
	jr MLM_update_ch_vol_return

; stop song
MLM_stop:
	push hl
	push de
	push bc
	push af
		; Stop SSG Controller
		call SSGCNT_init
		call FMCNT_init

		; clear MLM WRAM
		ld hl,MLM_wram_start
		ld de,MLM_wram_start+1
		ld bc,MLM_wram_end-MLM_wram_start-1
		ld (hl),0
		ldir

		; Set WRAM variables
		;ld a,1
		;ld (MLM_base_time),a

		; Clear other WRAM variables
		xor a,a
		ld (EXT_2CH_mode),a

		call ssg_stop
		call fm_stop
		call PA_reset
		call pb_stop
	pop af
	pop bc
	pop de
	pop hl
	ret

; a: song
MLM_play_song:
	push hl
	push bc
	push de
	push ix
	push af
		call MLM_stop
		call set_default_banks 

		; First song index validity check
		;	If the song is bigger or equal to 128
		;   (thus bit 7 is set), the index is invalid.
		bit 7,a
		call nz,softlock ; if a's bit 7 is set then ..

		; Second song index validity check
		;	If the song is bigger or equal to the
		;   song count, the index is invalid.
		ld hl,MLM_HEADER
		ld c,(hl)
		cp a,c
		call nc,softlock ; if a >= c then ...

		; Load song header offset 
		; from MLM header into de,
		; then add MLM_songs to it
		; to obtain a pointer.
		inc hl
		sla a
		ld d,0
		ld e,a
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)
		ld hl,MLM_HEADER
		add hl,de

		;     For each channel...
		ld de,MLM_playback_pointers
		ld ix,MLM_playback_control
		ld b,CHANNEL_COUNT
MLM_play_song_loop:
		call MLM_playback_init
		djnz MLM_play_song_loop

		; Load timer a counter load
		; from song header and set it
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		call ta_counter_load_set
		ex de,hl

		; Load base time from song
		; header and store it into WRAM
		inc hl
		ld a,(hl)
		ld (MLM_base_time),a

		; Load instrument offset into de
		inc hl
		ld e,(hl)
		inc hl
		ld d,(hl)

		; Calculate actual address, then
		; load said address into WRAM
		ld hl,MLM_HEADER
		add hl,de
		ld a,l
		ld (MLM_instruments),a
		ld a,h
		ld (MLM_instruments+1),a

		; Copy MLM_playback_pointers
		; to MLM_playback_start_pointers
		ld hl,MLM_playback_pointers
		ld de,MLM_playback_start_pointers
		ld bc,2*CHANNEL_COUNT
		ldir

		; Set all the channel's
		; volumes to $FF
		ld hl,MLM_channel_volumes
		ld de,MLM_channel_volumes+1
		ld bc,CHANNEL_COUNT-1
		ld (hl),$FF
		ldir

		; Set ADPCM-A master volume
		ld de,REG_PA_MVOL<<8 | $3F
		rst RST_YM_WRITEB

		; Enable all FM channels
		ld c,0
		call FM_enable_channel
		ld c,1
		call FM_enable_channel
		ld c,2
		call FM_enable_channel
		ld c,3
		call FM_enable_channel

		ld b,CHANNEL_COUNT
MLM_play_song_loop2:
		call MLM_ch_parameters_init
		djnz MLM_play_song_loop2
	pop af
	pop ix
	pop de
	pop bc
	pop hl
	ret

; [INPUT]
;	b:	channel+1
;	de:	$MLM_playback_pointers[ch]
;	ix:	$MLM_playback_control[ch]
; [OUTPUT]
;	de:	$MLM_playback_pointers[ch+1]
;	ix:	$MLM_playback_control[ch+1]
MLM_playback_init:
	push bc
	push af
		; Set all channel timings to 1
		ld a,b
		dec a
		ld bc,1
		call MLM_set_timing

		; Load channel's playback offset
		; into bc
		ld c,(hl)
		inc hl
		ld b,(hl)
		inc hl

		; Obtain ptr to channel's playback
		; data by adding MLM_HEADER to its
		; playback offset.
		;	Only the due words' MSB need
		;	to be added together, since
		;	the LSB is always equal to $00.
		ld a,MLM_HEADER>>8
		add a,b

		; store said pointer into
		; MLM_playback_pointers[ch]
		ex de,hl
			ld (hl),c
			inc hl
			ld (hl),a
			inc hl
		ex de,hl

		; If the playback pointer isn't
		; equal to 0, set the channel's
		; playback control to $FF
		push hl
			ld hl,0
			or a,a ; Clear carry flag
			sbc hl,bc
			jr z,MLM_playback_init_no_playback
			ld (ix+0),$FF
MLM_playback_init_no_playback:
			inc ix
		pop hl
	pop af
	pop bc
	ret

; b: channel+1
;	Initializes channel parameters
MLM_ch_parameters_init:
	push af
	push bc
		ld a,b
		dec a
		ld c,PANNING_CENTER
		call MLM_set_channel_panning

		ld a,0
		ld c,b
		dec c
		call MLM_set_instrument
	pop bc
	pop af
	ret

; c: channel
MLM_update_events:
	push hl
	push de
	push af
	push ix
		; de = MLM_playback_pointers[ch]
		ld h,0
		ld l,c
		add hl,hl
		ld de,MLM_playback_pointers
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)

		brk
		push af
		ld a,$39
		ld (breakpoint),a
		pop af
		
		; If the first byte's most significant bit is 0, then
		; parse it and evaluate it as a note, else parse 
		; and evaluate it as a command
		ex de,hl
		ld a,(hl)
		bit 7,a
		call z,MLM_parse_command
		call nz,MLM_parse_note

MLM_update_events_skip:
	pop ix
	pop af
	pop de
	pop hl
	ret

;   c:  channel
;   hl: source (playback pointer)
;   de: $MLM_playback_pointers[channel]+1
MLM_parse_note:
	push af
	push bc
	push hl
	push de
		ld a,(hl)
		and a,$7F ; Clear bit 7 of the note's first byte
		ld b,a
		ld a,c    ; move channel in a
		inc hl
		ld c,(hl)
		inc hl
		
		; if (channel < 6) MLM_parse_note_pa()
		cp a,6
		jp c,MLM_play_sample_pa

		cp a,10
		jp c,MLM_play_note_fm
		jp MLM_play_note_ssg
MLM_parse_note_end:
		; store playback pointer into WRAM
		ex de,hl
		ld (hl),d
		dec hl
		ld (hl),e
	pop de
	pop hl
	pop bc
	pop af
	ret

; [INPUT]
;   a:  channel
;   bc: source   (-TTTTTTT SSSSSSSS (Timing; Sample))
MLM_play_sample_pa:
	push de
	push bc
	push hl
	push ix
		; Load current instrument index into hl
		ld h,0
		ld l,a 
		ld de,MLM_channel_instruments
		add hl,de
		ld l,(hl)
		ld h,0

		; Load pointer to instrument data
		; from WRAM into de
		push af
			ld a,(MLM_instruments)
			ld e,a
			ld a,(MLM_instruments+1)
			ld d,a
		pop af

		; Calculate pointer to the current
		; instrument's data and store it in hl
		add hl,hl ; \
		add hl,hl ;  \
		add hl,hl ;   | hl *= 32
		add hl,hl ;  /
		add hl,hl ; /
		add hl,de

		; Store offset to ADPCM 
		; sample table in hl
		ld e,(hl)
		inc hl
		ld d,(hl)

		; Add MLM_header offset to
		; it to obtain the actual address
		ld hl,MLM_HEADER
		add hl,de
		ld e,l
		ld d,h

		; Check if sample id is valid;
		; if it isn't softlock.
		push af
			ld a,c
			cp a,(hl)
			jp nc,softlock ; if smp_id >= smp_count
			inc de ; Increment past sample count
		pop af

		; ix = $ADPCM_sample_table[sample_idx]
		ld h,0
		ld l,c
		add hl,hl ; - hl *= 4
		add hl,hl ; /
		add hl,de
		ex de,hl
		ld ixl,e
		ld ixh,d

		call PA_set_sample_addr

		; Set timing
		ld c,b
		ld b,0
		call MLM_set_timing
		
		; play sample
		ld h,0
		ld l,a
		ld de,PA_channel_on_masks
		add hl,de
		ld d,REG_PA_CTRL
		ld e,(hl) 
		rst RST_YM_WRITEB
	pop ix
	pop hl
	pop bc
	pop de
	jp MLM_parse_note_end

; [INPUT]
;   a:  channel+6
;   bc: source (-TTTTTTT -OOONNNN (Timing; Octave; Note))
MLM_play_note_fm:
	push af
	push ix
	push bc
		sub a,MLM_CH_FM1
		ld ixh,c
		ld ixl,a
		call FMCNT_set_note
		ld c,a
		call FMCNT_play_channel

		add a,MLM_CH_FM1
		ld c,b
		ld b,0
		call MLM_set_timing
	pop bc
	pop ix
	pop af
	jp MLM_parse_note_end

;   a:  channel+10
;   bc: source (-TTTTTTT NNNNNNNN (Timing; Note))
MLM_play_note_ssg:
	push af
	push bc
		sub a,MLM_CH_SSG1
		call SSGCNT_set_note
		call SSGCNT_enable_channel
		call SSGCNT_start_channel_macros

		add a,MLM_CH_SSG1
		ld c,b
		ld b,0
		call MLM_set_timing
	pop bc
	pop af
	jp MLM_parse_note_end

; a: instrument
; c: channel
MLM_set_instrument:
	push bc
	push hl
	push af
		; Store instrument in MLM_channel_instruments
		ld b,0
		ld hl,MLM_channel_instruments
		add hl,bc
		ld (hl),a

		; if the channel is ADPCM-A nothing
		; else needs to be done: return
		ld a,c
		cp a,MLM_CH_FM1                ; if a < MLM_CH_FM1 
		jr c,MLM_set_instrument_return ; then ...

		; If the channel is FM, for now
		; do nothing. TODO make it do something
		cp a,MLM_CH_SSG1               ; if a < MLM_CH_SSG1
		jr c,MLM_set_instrument_fm     ; then ...

		; Else the channel is SSG, branch
		jr MLM_set_instrument_ssg
MLM_set_instrument_return:
	pop af
	pop hl
	pop bc
	ret

; a:  channel
; hl: $MLM_channel_instruments[channel]
MLM_set_instrument_fm:
	push hl
	push de
	push bc
	push af
		; Load pointer to instrument data
		; from WRAM into de
		push af
			ld a,(MLM_instruments)
			ld e,a
			ld a,(MLM_instruments+1)
			ld d,a
		pop af

		; Calculate pointer to instrument
		ld l,(hl)
		ld h,0
		add hl,hl ; \
		add hl,hl ;  \
		add hl,hl ;  | hl *= 32
		add hl,hl ;  /
		add hl,hl ; /
		add hl,de

		; Set feedback $ algorithm
		sub a,MLM_CH_FM1
		ld c,a
		ld a,(hl)
		call FMCNT_set_fbalgo

		; Set AMS and PMS
		inc hl
		ld a,(hl)
		call FMCNT_set_amspms

		; Set OP enable
		inc hl
		ld a,(hl)
		call FMCNT_set_op_enable

		; Set operators
		ld b,0
		inc hl
		ld de,7 ; operator data size

		; Set OP 1
		call FMCNT_set_operator
		add hl,de
		inc b

		; Set OP 2
		call FMCNT_set_operator
		add hl,de
		inc b

		; Set OP 3
		call FMCNT_set_operator
		add hl,de
		inc b

		; Set OP 4
		call FMCNT_set_operator
		add hl,de
	pop af
	pop bc
	pop de
	pop hl
	jr MLM_set_instrument_return

; a:  channel
; hl: $MLM_channel_instruments[channel]
MLM_set_instrument_ssg:
	push de
	push hl
	push bc
	push af
	push ix
		; Load pointer to instrument data
		; from WRAM into de
		push af
			ld a,(MLM_instruments)
			ld e,a
			ld a,(MLM_instruments+1)
			ld d,a
		pop af

		; Calculate pointer to instrument
		ld l,(hl)
		ld h,0
		add hl,hl ; \
		add hl,hl ;  \
		add hl,hl ;  | hl *= 32
		add hl,hl ;  /
		add hl,hl ; /
		add hl,de

		; Calculate SSG channel
		; in 0~2 range
		sub a,MLM_CH_SSG1
		ld d,a                    ; Channel parameter

		; Enable tone if the mixing's byte
		; bit 0 is 1, else disable it
		ld a,(hl)
		and a,%00000001 ; Get tone enable bit
		ld c,a                    ; Enable/Disable parameter
		ld e,SSGCNT_MIX_EN_TUNE   ; Tune/Noise select parameter
		call SSGCNT_set_mixing

		; Enable noise if the mixing's byte
		; bit 1 is 1, else disable it
		ld a,(hl)
		and a,%00000010 ; Get noise enable bit
		srl a
		ld c,a                   ; Enable/Disable parameter
		ld e,SSGCNT_MIX_EN_NOISE ; Tune/Noise select parameter
		call SSGCNT_set_mixing

		; Skip EG parsing (TODO: parse EG information)
		inc hl
		inc hl
		inc hl
		inc hl
		inc hl

		; Calculate pointer to channel's mix macro
		ld ixh,0
		ld ixl,d 
		add ix,ix ; \
		add ix,ix ; | ix *= 8
		add ix,ix ; /
		ld bc,SSGCNT_mix_macro_A
		add ix,bc

		; Set mix macro
		ld e,(hl) ; \
		inc hl    ; | Store macro data
		ld d,(hl) ; | offset in hl
		ex de,hl  ; /
		push de              ; \
			ld de,MLM_HEADER ; | Add MLM header offset to
			add hl,de        ; | obtain the actual address
		pop de               ; /
		call SSGCNT_MACRO_set
		
		; Calculate pointer to volume macro
		; initialization data (hl) and pointer
		; to the volume macro in WRAM (ix)
		ex de,hl
		inc hl
		ld bc,ControlMacro.SIZE*3
		add ix,bc

		; Set volume macro
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		push de              ; \
			ld de,MLM_HEADER ; | Add MLM header offset to
			add hl,de        ; | obtain the actual address
		pop de               ; /
		call SSGCNT_MACRO_set

		; Set arpeggio macro
		ex de,hl
		inc hl
		add ix,bc
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		push de              ; \
			ld de,MLM_HEADER ; | Add MLM header offset to
			add hl,de        ; | obtain the actual address
		pop de               ; /
		call SSGCNT_MACRO_set
	pop ix
	pop af
	pop bc
	pop hl
	pop de
	jp MLM_set_instrument_return

; a:  channel
; bc: timing
MLM_set_timing:
	push hl
	push de
		ld h,0
		ld l,a
		ld de,MLM_playback_timings
		add hl,hl
		add hl,de
		ld (hl),c
		inc hl
		ld (hl),b

		ld de,MLM_playback_set_timings-MLM_playback_timings
		add hl,de
		ld (hl),b
		dec hl
		ld (hl),c
	pop de
	pop hl
	ret

; a: channel (MLM)
MLM_stop_note:
	push hl
	push de
	push af
		ld h,0
		ld l,a
		ld de,MLM_stop_note_vectors
		add hl,hl
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		jp (hl)
MLM_stop_note_return:
	pop af
	pop de
	pop hl
	ret

MLM_stop_note_vectors:
	dw MLM_stop_note_PA,MLM_stop_note_PA
	dw MLM_stop_note_PA,MLM_stop_note_PA
	dw MLM_stop_note_PA,MLM_stop_note_PA
	dw MLM_stop_note_FM,MLM_stop_note_FM
	dw MLM_stop_note_FM,MLM_stop_note_FM
	dw MLM_stop_note_SSG,MLM_stop_note_SSG
	dw MLM_stop_note_SSG

; a: channel
MLM_stop_note_PA:
	call PA_stop_sample
	jp MLM_stop_note_return

; a: channel
MLM_stop_note_FM:
	push bc
	push af
		sub a,MLM_CH_FM1
		ld c,a
		call FMCNT_stop_channel
	pop af
	pop bc
	jp MLM_stop_note_return

; a: channel
MLM_stop_note_SSG:
	sub a,MLM_CH_SSG1
	call SSGCNT_disable_channel
	jp MLM_stop_note_return

; a: volume
; c: channel
;	This sets MLM_channel_volumes,
;   the register writes are done in
;   the IRQ
MLM_set_channel_volume:
	push hl
	push bc
	push af
		ld hl,MLM_channel_volumes
		ld b,0
		add hl,bc
		ld (hl),a
MLM_set_channel_volume_return:
	pop af
	pop bc
	pop hl
	ret

; a: channel
; c: panning (LR------)
MLM_set_channel_panning:
	push hl
	push de
	push af
		ld h,0
		ld l,a
		ld de,MLM_set_ch_pan_vectors
		add hl,hl
		add hl,de
		ld e,(hl)
		inc hl
		ld d,(hl)
		ex de,hl
		jp (hl)
MLM_set_ch_pan_ret:
	pop af
	pop de
	pop hl
	ret

MLM_set_ch_pan_vectors:
	dw MLM_set_ch_pan_PA,MLM_set_ch_pan_PA
	dw MLM_set_ch_pan_PA,MLM_set_ch_pan_PA
	dw MLM_set_ch_pan_PA,MLM_set_ch_pan_PA
	dw MLM_set_ch_pan_FM,MLM_set_ch_pan_FM
	dw MLM_set_ch_pan_FM,MLM_set_ch_pan_FM
	dw MLM_set_ch_pan_ret,MLM_set_ch_pan_ret
	dw MLM_set_ch_pan_ret ; SSG is mono

MLM_set_ch_pan_PA:
	call PA_set_channel_panning
	jr MLM_set_ch_pan_ret

MLM_set_ch_pan_FM:
	push bc
	push af
		sub a,MLM_CH_FM1
		ld b,c ; \
		ld c,a ; | swap a and c
		ld a,b ; /
		call FMCNT_set_panning
	pop af
	pop bc
	jr MLM_set_ch_pan_ret

;   c:  channel
;   hl: source (playback pointer)
;   de: $MLM_playback_pointers[channel]+1
MLM_parse_command:
	push af
	push bc
	push ix
	push hl
	push de
	push iy
		; Backup $MLM_playback_pointers[channel]+1
		; into ix
		ld ixl,e
		ld ixh,d

		; backup the command's first byte into iyl
		ld a,(hl)
		ld iyl,a

		; Lookup command argc and store it into a
		push hl
			ld l,(hl)
			ld h,0
			ld de,MLM_command_argc
			add hl,de
			ld a,(hl)
		pop hl

		; Lookup command vector and store it into de
		push hl
			ld l,(hl)
			ld h,0
			ld de,MLM_command_vectors
			add hl,hl
			add hl,de
			ld e,(hl)
			inc hl
			ld d,(hl)
		pop hl

		inc hl

		; If the command's argc is 0, 
		; just execute the command
		or a,a ; cp a,0
		jr z,MLM_parse_command_execute

		; if it isn't, load arguments into
		; MLM_event_arg_buffer beforehand
		; and add argc to hl
		push de
		push bc
			ld de,MLM_event_arg_buffer
			ld b,0
			ld c,a
			ldir
		pop bc
		pop de

MLM_parse_command_execute:
		ex de,hl
		jp (hl)

MLM_parse_command_end:
		ex de,hl
		
		; Load $MLM_playback_pointers[channel]
		; back into de
		ld e,ixl
		ld d,ixh

		; store playback pointer into WRAM
		ex de,hl
		ld (hl),d
		dec hl
		ld (hl),e

MLM_parse_command_end_skip_playback_pointer_set:
	pop iy
	pop de
	pop hl
	pop ix
	pop bc
	pop af
	ret

MLM_command_vectors:
	dw MLMCOM_end_of_list,         MLMCOM_note_off
	dw MLMCOM_set_instrument,      MLMCOM_wait_ticks_byte
	dw MLMCOM_wait_ticks_word,     MLMCOM_set_channel_volume
	dw MLMCOM_set_channel_panning, MLMCOM_set_master_volume
	dw MLMCOM_set_base_time,       MLMCOM_jump_to_sub_el
	dw MLMCOM_small_position_jump, MLMCOM_big_position_jump
	dw MLMCOM_portamento_slide,    MLMCOM_porta_write
	dw MLMCOM_portb_write,         MLMCOM_set_timer_a
	dup 16
		dw MLMCOM_wait_ticks_nibble
	edup
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
		dw MLMCOM_wait_ticks_nibble
	dw MLMCOM_return_from_sub_el
	dup 15
		dw MLMCOM_invalid ; Invalid commands
	edup
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
	dup 16
		dw MLMCOM_set_channel_volume_byte
	edup
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
		dw MLMCOM_set_channel_volume_byte
	dup 64
		dw MLMCOM_invalid ; Invalid commands
	edup
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands
		dw MLMCOM_invalid ; Invalid commands

MLM_command_argc:
	db $00, $01, $01, $01, $02, $01, $01, $01
	db $01, $02, $01, $02, $01, $02, $02, $02
	ds 16, $00 ; Wait ticks nibble
	db $00
	ds 15, 0   ; Invalid commands all have no arguments
	ds 16, 0   ; Set Channel Volume (byte sized)
	ds 64, 0   ; Invalid commands all have no arguments

; c: channel
MLMCOM_end_of_list:
	push hl
	push de
	push af
	push bc
		; Set playback control to 0
		ld h,0
		ld l,c
		ld de,MLM_playback_control
		add hl,de
		ld (hl),0

		; Set timing to 1
		; (This is done to be sure that
		;  the next event won't be executed)
		ld a,c
		ld bc,1
		call MLM_set_timing
MLMCOM_end_of_list_return:
	pop bc
	pop af
	pop de
	pop hl
	jp MLM_parse_command_end

; c: channel
; Arguments:
; 	1. timing
MLMCOM_note_off:
	push hl
	push af
	push de
	push bc
		ld a,c
		call MLM_stop_note
		ld hl,MLM_event_arg_buffer
		ld a,c
		ld b,0
		ld c,(hl)
		call MLM_set_timing
	pop bc
	pop de
	pop af
	pop hl
	jp MLM_parse_command_end

; c: channel
; Arguments
;   1. instrument
MLMCOM_set_instrument:
	push af
	push bc
		ld a,(MLM_event_arg_buffer)
		call MLM_set_instrument
		ld a,c
		ld bc,0
		call MLM_set_timing
	pop bc
	pop af
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. timing
MLMCOM_wait_ticks_byte:
	push hl
	push bc
	push af
		ld hl,MLM_event_arg_buffer
		ld a,c
		ld b,0
		ld c,(hl)
		inc bc
		call MLM_set_timing
	pop af
	pop bc
	pop hl
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. timing (LSB)
;   2. timing (MSB)
MLMCOM_wait_ticks_word:
	push hl
	push bc
	push af
	push ix
		ld ix,MLM_event_arg_buffer
		ld a,c
		ld b,(ix+1)
		ld c,(ix+0)
		call MLM_set_timing
	pop ix
	pop af
	pop bc
	pop hl
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. Volume
MLMCOM_set_channel_volume:
	push ix
	push af
	push hl
	push bc
		ld ix,MLM_event_arg_buffer
		ld a,c ; backup channel into a

		; Store volume in 
		; MLM_channel_volumes[channel]
		ld h,0
		ld l,a
		ld bc,MLM_channel_volumes
		add hl,bc
		ld c,(ix+0)
		ld (hl),c

		; Set timing
		ld bc,0
		call MLM_set_timing
	pop bc
	pop hl
	pop af
	pop ix
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %LRTTTTTT (Left on; Right on; Timing)
MLMCOM_set_channel_panning:
	push af
	push hl
	push bc
	push de
		; Load panning into c
		ld a,(MLM_event_arg_buffer)
		and a,%11000000
		ld b,a ; \
		ld a,c ;  |- Swap a and c sacrificing b
		ld c,b ; /

		call MLM_set_channel_panning

MLMCOM_set_channel_panning_set_timing:
		ld b,a ; backup channel in b
		ld a,(MLM_event_arg_buffer)
		and a,%00111111 ; Get timing
		ld c,a
		ld a,b
		ld b,0
		call MLM_set_timing
	pop de
	pop bc
	pop hl
	pop af
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %VVVVVVTT (Volume; Timing MSB)
MLMCOM_set_master_volume:
	push ix
	push af
	push de
	push bc
		ld ix,MLM_event_arg_buffer

		; Set master volume
		ld a,(ix+0)
		srl a ; %VVVVVV-- -> %-VVVVVV-
		srl a ; %-VVVVVV- -> %--VVVVVV
		ld d,REG_PA_MVOL
		ld e,a
		rst RST_YM_WRITEB

		; Set timing
		ld a,(ix+0)
		and a,%00000011
		ld b,a
		ld a,c
		ld c,b
		ld b,0
		call MLM_set_timing
	pop bc
	pop de
	pop af
	pop ix
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %BBBBBBBB (Base time)
MLMCOM_set_base_time:
	push ix
	push af
		ld ix,MLM_event_arg_buffer

		; Set base time
		ld a,(ix+0)
		ld (MLM_base_time),a

		; Set timing
		ld a,c
		ld bc,0
		call MLM_set_timing
	pop af
	pop ix
	jp MLM_parse_command_end

; c: channel
; ix: $MLM_playback_pointers[channel]+1
; de: source (playback pointer; points to next command)
; Arguments:
;	1. %AAAAAAAA (Address LSB)
;	2. %AAAAAAAA (Address MSB)
MLMCOM_jump_to_sub_el:
	push hl
	push af
	push bc
	push de
		; Store playback pointer in WRAM
		ld b,0
		ld hl,MLM_sub_el_return_pointers
		add hl,bc
		add hl,bc
		ld (hl),e
		inc hl
		ld (hl),d

		; Load address to jump to in de
		ld hl,MLM_event_arg_buffer
		ld e,(hl)
		inc hl
		ld d,(hl)

		; Add MLM_HEADER ($4000) to it 
		; to obtain the actual address
		ld hl,MLM_HEADER
		add hl,de

		; Store the actual address in WRAM
		ld (ix-1),l
		ld (ix-0),h

		; Set timing to 0
		; (Execute next command immediately)
		ld a,c
		ld bc,0
		call MLM_set_timing
	pop de
	pop bc
	pop af
	pop hl
	jp MLM_parse_command_end_skip_playback_pointer_set

; c:  channel
; ix: $MLM_playback_pointers[channel]+1
; de: source (playback pointer)
; Arguments:
;   1. %OOOOOOOO (Offset)
MLMCOM_small_position_jump:
	push hl
	push de
	push ix
		ld hl,MLM_event_arg_buffer

		; Load offset and sign extend 
		; it to 16bit (result in bc)
		ld a,(hl)
		ld l,c     ; Backup channel into l
		call AtoBCextendendsign

		; Add offset to playback 
		; pointer and store it into 
		; MLM_playback_pointers[channel]
		ld a,l ; Backup channel into a
		ld l,e
		ld h,d
		add hl,bc
		ld (ix-1),l
		ld (ix-0),h

		; Set timing to 0
		ld bc,0
		call MLM_set_timing
	pop ix
	pop de
	pop hl
	jp MLM_parse_command_end_skip_playback_pointer_set

; c:  channel
; ix: $MLM_playback_pointers[channel]+1
; de: source (playback pointer)
; Arguments:
;   1. %AAAAAAAA (Address LSB)
;   2. %AAAAAAAA (Address MSB)
MLMCOM_big_position_jump:
	push hl
	push ix
	push af
	push bc
		ld hl,MLM_event_arg_buffer

		; Load offset into bc
		ld a,c ; Backup channel into a
		ld c,(hl)
		inc hl
		ld b,(hl)

		; Add MLM header offset to 
		; obtain the actual address
		ld hl,MLM_HEADER
		add hl,bc
		ld (ix-1),l
		ld (ix-0),h

		; Set timing to 0
		ld bc,0
		call MLM_set_timing
	pop bc
	pop af
	pop ix
	pop hl
	jp MLM_parse_command_end_skip_playback_pointer_set

; c: channel
; Arguments:
;   1. %SSSSSSSS (Signed pitch offset per tick)
MLMCOM_portamento_slide:
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %AAAAAAAA (Address)
;   2. %DDDDDDDD (Data)
MLMCOM_porta_write:
	push de
	push ix
	push af
	push bc
		ld ix,MLM_event_arg_buffer

		ld d,(ix+0)
		ld e,(ix+1)
		rst RST_YM_WRITEA

		ld a,c
		ld bc,0
		call MLM_set_timing

		; If address isn't equal to 
		; REG_TIMER_CNT return
		ld a,d
		cp a,REG_TIMER_CNT
		jr nz,MLMCOM_porta_write_return

		; If address is equal to $27, then
		; store the data's 7th bit in WRAM
		ld a,e
		and a,%01000000 ; bit 6 enables 2CH mode
		ld (EXT_2CH_mode),a
		
MLMCOM_porta_write_return:
	pop bc
	pop af
	pop ix
	pop de
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %AAAAAAAA (Address)
;   2. %DDDDDDDD (Data)
MLMCOM_portb_write:
	push de
	push ix
	push af
	push bc
		ld ix,MLM_event_arg_buffer

		ld d,(ix+0)
		ld e,(ix+1)
		rst RST_YM_WRITEB

		ld a,c
		ld bc,0
		call MLM_set_timing
	pop bc
	pop af
	pop ix
	pop de
	jp MLM_parse_command_end

; c: channel
; Arguments:
;   1. %AAAAAAAA (timer A MSB) 
;   2. %TTTTTTAA (Timing; timer A LSB)
MLMCOM_set_timer_a:
	push ix
	push bc
	push af
	push de
		ld ix,MLM_event_arg_buffer
		ld e,c ; backup channel in e

		; Set timer a counter load
		ld d,REG_TMA_COUNTER_MSB
		ld e,(ix+0)
		rst RST_YM_WRITEA
		inc d
		ld e,(ix+1)
		rst RST_YM_WRITEA
		ld de,REG_TIMER_CNT<<8 | %10101
		RST RST_YM_WRITEA

		ld b,0
		ld a,(ix+1)
		srl a
		srl a
		ld c,a
		ld a,e
		call MLM_set_timing
	pop de
	pop af
	pop bc
	pop ix
	jp MLM_parse_command_end

; c: channel
; de: playback pointer
MLMCOM_wait_ticks_nibble:
	push hl
	push af
	push bc
		; Load command ($1T) in a
		ld h,d
		ld l,e
		dec hl
		ld a,(hl)
		ld l,c ; backup channel

		and a,$0F ; get timing
		ld c,a
		ld b,0
		ld a,l
		inc c ; 0~15 -> 1~16
		call MLM_set_timing
	pop bc
	pop af
	pop hl
	jp MLM_parse_command_end

; c: channel
; ix: $MLM_playback_pointers[channel]+1
; de: source (playback pointer)
MLMCOM_return_from_sub_el:
	push hl
	push af
	push bc
		; Load playback pointer in WRAM
		; and store it into MLM_playback_pointers[channel]
		ld b,0
		ld hl,MLM_sub_el_return_pointers
		add hl,bc
		add hl,bc
		ld a,(hl)   ; - Load and store address LSB
		ld (ix-1),a ; /
		inc hl		; \
		ld a,(hl)   ; | Load and store address MSB
		ld (ix-0),a ; /

		; Set timing to 0
		; (Execute next command immediately)
		ld a,c
		ld bc,0
		call MLM_set_timing
	pop bc
	pop af
	pop hl
	jp MLM_parse_command_end_skip_playback_pointer_set


; c: channel
; de: playback pointer
MLMCOM_set_channel_volume_byte:
	push af
	push bc

		ld a,c
		cp a,MLM_CH_FM1
		jp c,MLMCOM_set_channel_volume_byte_ADPCMA

		cp a,MLM_CH_SSG1
		jp c,MLMCOM_set_channel_volume_byte_FM

		jp MLMCOM_set_channel_volume_byte_SSG

MLMCOM_set_channel_volume_byte_ret:

		ld a,c
		ld bc,0
		call MLM_set_timing
	pop bc
	pop af
	jp MLM_parse_command_end

; a: channel
; c: channel
; de: playback pointer
MLMCOM_set_channel_volume_byte_ADPCMA:
	push af
	push hl
	push bc
	push de
		; Load command byte in l
		ex de,hl
		dec hl
		ld e,(hl)
		ex de,hl

		; Store offset from com byte
		; in a and increment it by 1
		ld a,l
		and a,$07
		inc a

		; Shift offset to the left
		; to adjust the offset to
		; the ADPCM-A range ($00~$1F)
		sla a
		sla a
		sla a

		; If the sign bit is set, 
		; negate offset
		bit 3,l
		jr z,MLMCOM_set_channel_volume_byte_ADPCMA_pos
		neg ; negates a

MLMCOM_set_channel_volume_byte_ADPCMA_pos:
		; Calculate address to channel volume
		ld hl,MLM_channel_volumes
		ld b,0
		add hl,bc

		; Add offset to channel volume
		add a,(hl)
		call MLM_set_channel_volume
	pop de
	pop bc
	pop hl
	pop af
	jp MLMCOM_set_channel_volume_byte_ret

; a: channel
; c: channel
; de: playback pointer
MLMCOM_set_channel_volume_byte_FM:
	push af
	push hl
	push bc
	push de
		; Load command byte in l
		ex de,hl
		dec hl
		ld e,(hl)
		ex de,hl

		; Store offset from com byte
		; in a and increment it by 1
		ld a,l
		and a,$07
		inc a

		; Shift offset to the left
		; to adjust the offset to
		; the FM range ($00~$7F)
		sla a

		; If the sign bit is set, 
		; negate offset
		bit 3,l
		jr z,MLMCOM_set_channel_volume_byte_FM_pos
		neg ; negates a

MLMCOM_set_channel_volume_byte_FM_pos:
		; Calculate address to channel volume
		ld hl,MLM_channel_volumes
		ld b,0
		add hl,bc

		; Add offset to channel volume
		add a,(hl)
		call MLM_set_channel_volume
	pop de
	pop bc
	pop hl
	pop af
	jp MLMCOM_set_channel_volume_byte_ret


; a: channel
; c: channel
; de: playback pointer
MLMCOM_set_channel_volume_byte_SSG:
	push af
	push de
		; Load command byte in a, and 
		; then get the volume from the 
		; least significant nibble of it
		ex de,hl
		dec hl
		ld a,(hl)
		ex de,hl
		and a,$0F

		; Transform SSG Volume ($00~$0F)
		; into an MLM volume ($00~$FF)
		sla a ; -\
		sla a ;  | a <<= 4
		sla a ;  /
		sla a ; /

		call MLM_set_channel_volume
	pop de
	pop af
	jp MLMCOM_set_channel_volume_byte_ret

; invalid command, plays a noisy beep
; and softlocks the driver
MLMCOM_invalid:
	call softlock
	include "math.s"
;Inputs:
;     H,E
;Outputs:
;     HL is the product
;     D,B are 0
;     A,E,C are preserved
;Size:  38 bytes
;Speed: 198+6b+9p-7s, b is the number of bits set in the input H, p is if it is odd, s is the upper bit of h
;   average is 226.5 cycles (108.5 cycles saved)
;   max required is 255 cycles (104 cycles saved)
H_Times_E:
     ld d,0      ;1600   7   7
     ld l,d      ;6A     4   4
     ld b,8      ;0608   7   7
           ;      
     sla h   ;   8
     jr nc,$+3   ;3001  12-b
     ld l,e   ;6B    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29    11
     jr nc,$+3   ;3001  12+6b
     add hl,de   ;19    --

     add hl,hl   ;29   11
     ret nc      ;D0   11+15p
     add hl,de   ;19   --
     ret         ;C9   --

;Inputs:
;     HL is the numerator
;     C is the denominator
;Outputs:
;     A is the remainder
;     B is 0
;     C is not changed
;     DE is not changed
;     HL is the quotient
;
HL_Div_C:
       ld b,16
       xor a
         add hl,hl
         rla
         cp c
         jr c,$+4
           inc l
           sub c
         djnz $-7
       ret

;Inputs:
;     HL is the numerator
;     C is the denominator
;Outputs:
;     A is twice the remainder of the unrounded value 
;     B is 0
;     C is not changed
;     DE is not changed
;     HL is the rounded quotient
;     c flag set means no rounding was performed
;            reset means the value was rounded
;
RoundHL_Div_C:
       ld b,16
       xor a
         add hl,hl
         rla
         cp c
         jr c,$+4
           inc l
           sub c
         djnz $-7
       add a,a
       cp c
       jr c,$+3
         inc hl
       ret

DE_Div_BC:          ;1281-2x, x is at most 16
     ld a,16        ;7
     ld hl,0        ;10
     jp $+5         ;10
DivLoop:
       add hl,bc    ;--
       dec a        ;64
       ret z        ;86

       sla e        ;128
       rl d         ;128
       adc hl,hl    ;240
       sbc hl,bc    ;240
       jr nc,DivLoop ;23|21
       inc e        ;--
       jp DivLoop+1

;a to bc (extend sign)
;inputs:  a  - 8-bit signed number
;outputs: bc - same 16-bit signed number
AtoBCextendendsign:
  push af
    ld c,a
    rlca    ; or rla
    sbc a,a
    ld b,a
  pop af
  ret

; Inputs:
;   c: c is the number to be shifted left
;   b: b is how many bits c has to be shifted
;  Outputs
;   c: shifted number
;   b: 0
; DOESN'T CHANGE FLAGS
shift_left_c_by_b_bits:
  push af
    ld a,b
    or a,a
    jr z,shift_left_c_by_b_bits_loop_skip

shift_left_c_by_b_bits_loop:
    sla c
    djnz shift_left_c_by_b_bits_loop

shift_left_c_by_b_bits_loop_skip:
  pop af
  ret

; This subroutine does the same thing
; as shift_left_c_by_b_bits except it uses
; sll instead then sla
; Inputs:
;   c: c is the number to be shifted left
;   b: b is how many bits c has to be shifted
;  Outputs
;   c: shifted number
;   b: 0
; DOESN'T CHANGE FLAGS
shift_left_c_by_b_bits_1:
  push af
    ld a,b
    or a,a
    jr z,shift_left_c_by_b_bits_loop_skip

shift_left_c_by_b_bits_1_loop:
    sll c
    djnz shift_left_c_by_b_bits_1_loop
    
shift_left_c_by_b_bits_1_loop_skip:
  pop af
  ret
	include "irq.s"
IRQ: ; MLM_2CH_mode
	push af
	push bc
	push de
	push hl
	push ix
	push iy
        brk2
		push af
		ld a,$3A
		ld (breakpoint),a
		pop af

        in a,(4)
        bit 0,a
        jr z,IRQ_end

        ;jp softlock

		call IRQ_handle_commands
		call MLM_irq
        call FMCNT_irq
        call SSGCNT_irq

        ld e,$00
        ld d,REG_TIMER_CNT
        ;rst RST_YM_WRITEA

        ld e,TM_CNT_LOAD_TA | TM_CNT_ENABLE_TA_IRQ | TM_CNT_TA_FLG_RESET
        ld d,REG_TIMER_CNT
		rst RST_YM_WRITEA

        brk2
		push af
		ld a,$3A
		ld (breakpoint),a
		pop af
IRQ_end:
	pop iy
	pop ix
	pop hl
	pop de
	pop bc
	pop af
	reti

; bc: word
IRQ_write2buffer:
    push af
    push bc
    push hl
    push de
        ; Calculate address to
        ; IRQ_buffer[IRQ_buffer_idx_w]
        ; and store it into hl
        ld hl,IRQ_buffer
        ld a,(IRQ_buffer_idx_w)
        and a,IRQ_BUFFER_LENGTH-1
        sla a  ; a *= 2
        ld d,0
        ld e,a
        add hl,de

        ; Store word into buffer
        ld (hl),c
        inc hl
        ld (hl),b

        ; increment buffer write
        ld a,(IRQ_buffer_idx_w)
        inc a
        and a,IRQ_BUFFER_LENGTH-1
        ld (IRQ_buffer_idx_w),a
    pop de
    pop hl
    pop bc
    pop af
    ret

IRQ_handle_commands:
    push af
    push bc
    push hl
IRQ_handle_command_loop:
        ; If the user communication buffers are equal,
        ; that means there are no new commands to run.
        ld a,(IRQ_buffer_idx_w) ; $F841
        ld b,a
        ld a,(IRQ_buffer_idx_r) ; $F842
        cp a,b 
        jr z,IRQ_handle_command_return

        ; Load command into bc, then
        ; parse and execute it.
        sla a  ; \
        ld c,a ; | bc = IRQ_buffer_idx_r*2
        ld b,0 ; /
        ld hl,IRQ_buffer
        add hl,bc
        ld c,(hl)
        inc hl
        ld b,(hl)

        call IRQ_run_command

        ; Set the current command
        ; word to $0000 (NOP)
        ld (hl),$00
        dec hl
        ld (hl),$00

        ; Increment IRQ_buffer_idx_r
        srl a ; a /= 2
        inc a
        and a,IRQ_BUFFER_LENGTH-1
        ld (IRQ_buffer_idx_r),a

        jr IRQ_handle_command_loop

IRQ_handle_command_return:
    pop hl
    pop bc
    pop af
    ret

; b: parameter
; c: command
IRQ_run_command:
    push af
    push bc
    push hl
    push de
        ; hl = $IRQ_command_vectors[command]
        ld l,c
        ld h,0
        ld de,IRQ_command_vectors
        add hl,hl
        add hl,de

        ; hl *= hl; 
        ld e,(hl)
        inc hl
        ld d,(hl)
        ex de,hl

        jp (hl)

IRQ_run_command_return:
    pop de
    pop hl
    pop bc
    pop af
    ret

IRQ_command_vectors:
    dw IRQ_CMD_nop,           IRQ_CMD_mlm_play_song
    dw IRQ_CMD_mlm_stop_song, IRQ_CMD_invalid
    dup 252
        dw IRQ_CMD_invalid
    edup
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
        dw IRQ_CMD_invalid
    
IRQ_CMD_nop:
    jp IRQ_run_command_return

; b: song
IRQ_CMD_mlm_play_song:
    push af
    	ld a,b
    	call MLM_play_song
    pop af
    jp IRQ_run_command_return

IRQ_CMD_mlm_stop_song:
    call MLM_stop
    jp IRQ_run_command_return

IRQ_CMD_invalid:
    call softlock

	org MLM_HEADER ; block 1
	include "mlm_test_data.s"
MLM_header:
	db 13 ; Song count
	dw MLM_song_pa1-MLM_header
	dw MLM_song_pa2-MLM_header
	dw MLM_song_pa3-MLM_header
	dw MLM_song_pa4-MLM_header
	dw MLM_song_pa5-MLM_header
	dw MLM_song_pa6-MLM_header
	dw MLM_song_fm1-MLM_header
	dw MLM_song_fm2-MLM_header
	dw MLM_song_fm3-MLM_header
	dw MLM_song_fm4-MLM_header
	dw MLM_song_ssg1-MLM_header
	dw MLM_song_ssg2-MLM_header
	dw MLM_song_ssg3-MLM_header

MLM_song_pa1:
	dw MLM_el_pa-MLM_header
	ds 12*2, 0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_pa2
	dw 0
	dw MLM_el_pa-MLM_header
	ds 11*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_pa3:
	ds 2*2,0
	dw MLM_el_pa-MLM_header
	ds 10*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_pa4:
	ds 3*2,0
	dw MLM_el_pa-MLM_header
	ds 9*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_pa5:
	ds 4*2,0
	dw MLM_el_pa-MLM_header
	ds 8*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_pa6:
	ds 5*2,0
	dw MLM_el_pa-MLM_header
	ds 7*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_el_pa: ; Start in Zone 3
	db $30 | 8 | (8-1) ; Offset volume by -8
	db $80 | 30, 0 ; Play ADPCM-A sample 0 (C)
	db $09                        ; - Jump to sub event list
	dw MLM_sub_el_wait-MLM_HEADER ; /

	db $30 | (6-1) ; Offset volume by +6
	db $80 | 30, 2 ; Play ADPCM-A sample 2 (D)
	db $00 ; End of song

MLM_sub_el_wait:
	db $01, 30
	db $20

MLM_song_fm1:
	ds 6*2,0
	dw MLM_el_fm-MLM_header
	ds 6*2,0
	dw 378 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_fm2:
	ds 7*2,0
	dw MLM_el_fm-MLM_header
	ds 5*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_fm3:
	ds 8*2,0
	dw MLM_el_fm-MLM_header
	ds 4*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_fm4:
	ds 9*2,0
	dw MLM_el_fm-MLM_header
	ds 3*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_el_fm:
	db $02,2 ; Set instrument to 2
	db $80 | (8*3), 0 | (5 << 4) ; Play FM note C4 and wait 8*3 ticks
	db $80 | (8*3), 2 | (5 << 4) ; Play FM note D4 and wait 8*3 ticks
	db $80 | (8*3), 4 | (5 << 4) ; Play FM note E4 and wait 8*3 ticks
	db $80 | (8*3), 5 | (5 << 4) ; Play FM note C4 and wait 8*3 ticks
	db $00
	
	; Jump to MLM_el_fm
	db $0B
	dw MLM_el_fm-MLM_header


MLM_song_ssg1:
	ds 10*2,0
	dw MLM_el_ssg-MLM_header
	ds 2*2,0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_ssg2:
	ds 11*2,0
	dw MLM_el_ssg-MLM_header
	dw 0
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header

MLM_song_ssg3:
	ds 12*2,0
	dw MLM_el_ssg-MLM_header
	dw 98 ; Timer A frequency
	db 1  ; base time (0 is invalid)
	dw MLM_song_instruments-MLM_header
	
MLM_el_ssg:
	db $02,1                  ; Set instrument to 1
	db $38 ; Set SSG volume to 8
	db $80 | 30,2*12 + 0 ; Play SSG note C4 and wait 30 ticks
	db $09                        ; - Jump to sub event list
	dw MLM_sub_el_wait-MLM_HEADER ; /

	db $3F ; Set SSG volume to F
	db $80 | 30,2*12 + 2 ; Play SSG note D4 and wait 30 ticks
 	db $00 ; End of song

MLM_song_instruments:
	; Instrument 0 (ADPCM-A)
	dw OTHER_DATA-MLM_header ; Point to ADPCM-A sample LUT (in Zone 1)
	ds 30,0 ; padding

	; Instrument 1 (SSG)
	db 1                               ; Mixing: Tone ON; Noise OFF
	db 0                               ; EG enable: OFF
	ds 3                               ; Skip EG information since EG is disabled
	dw $0000                           ; Mix macro      | MLM_odata_mix_macro1-MLM_header
	dw $0000                           ; Volume macro   | MLM_odata_vol_macro1-MLM_header
	dw MLM_odata_arp_macro1-MLM_header ; Arpeggio macro | 
	ds 21 ; Padding
	
	; Instrument 2 (FM)
	fm_ch_data 2,0,0,0                 ; feedback, algorithm, pms, ams
		.db 0 | (2 << 3)
		.db 0 | (0 << 4)
	db $F0                             ; Enable all 4 operators
	fm_op_data 3,1,38,2,31,0,4,6,1,7,0 ; dt,mul,tl,rs,a,am,d,d2,s,r,eg
		.db 1 | (3 << 4)
		.db 38
		.db 31 | (2 << 6)
		.db 4 | (0 << 7)
		.db 6
		.db 7 | (1 << 4)
		.db 0
	fm_op_data 3,0,40,2,31,0,4,5,1,7,0
		.db 0 | (3 << 4)
		.db 40
		.db 31 | (2 << 6)
		.db 4 | (0 << 7)
		.db 5
		.db 7 | (1 << 4)
		.db 0
	fm_op_data 3,0,13,0,31,0,9,5,1,7,0
		.db 0 | (3 << 4)
		.db 13
		.db 31 | (0 << 6)
		.db 9 | (0 << 7)
		.db 5
		.db 7 | (1 << 4)
		.db 0
	fm_op_data 3,1,10,0,31,0,4,3,1,7,0
		.db 1 | (3 << 4)
		.db 10
		.db 31 | (0 << 6)
		.db 4 | (0 << 7)
		.db 3
		.db 7 | (1 << 4)
		.db 0
	ds 1,0 ; Padding

	; Other data
	org OTHER_DATA
	incbin "adpcma_sample_lut.bin"
MLM_odata_mix_macro1:
	db (30*3)-1 ; Macro length
	db 30       ; Set loop point to 30
	ds 15,$11  ; 30 frames with tone enabled and noise disabled
	ds 15,$22  ; 30 frames with tone disabled and noise enabled
	ds 15,$33  ; 30 frames with tone and noise enabled

MLM_odata_vol_macro1:
	db 24-1 ; Macro length
	db 16   ; Loop point
	;  F E  D C  B A  9 8  7 6  5 4  3 2  1 0
	db $EF, $CD, $AB, $89, $67, $45, $23, $01
	;  2 4  6 8  A C  E F 
	db $42, $86, $CA, $FE

MLM_odata_arp_macro1:
	db 10-1 ; Macro length
	db 2    ; Loop point
	db -2,-2,-1,-1, 0, 0, 1, 1, 2, 2
	;incbin "m1_sdata.bin"

	include "wram.s"
	org WRAM_START

breakpoint: ds 1

com_buffer:              ds COM_BUFFER_LENGTH*2 ; u16[COM_BUFFER_LENGTH]
com_buffer_idx_w:        ds 1                   ; u8
com_buffer_idx_r:        ds 1                   ; u8

; If 0, then the z80 is waiting for the command's LSB,
; if 1, then the z80 is waiting for the command's MSB
; else, the behaviour is undefined.
com_buffer_byte_significance: ds 1                   ; u8

; ======== MLM player ========
MLM_wram_start:
MLM_playback_pointers:        ds 2*CHANNEL_COUNT     ; void*[13]
MLM_playback_start_pointers:  ds 2*CHANNEL_COUNT     ; void*[13]
MLM_playback_timings:         ds 2*CHANNEL_COUNT     ; u16[13]
MLM_playback_set_timings:     ds 2*CHANNEL_COUNT     ; u16[13]
MLM_playback_control:         ds CHANNEL_COUNT       ; bool[13]
MLM_event_arg_buffer:         ds 32                  ; u8[32]
MLM_channel_instruments:      ds CHANNEL_COUNT       ; u8[13]
MLM_channel_pannings:         ds CHANNEL_COUNT       ; u8[13]
MLM_channel_volumes:          ds CHANNEL_COUNT       ; u8[13]
MLM_base_time:                ds 1                   ; u8
MLM_base_time_counter:        ds 1                   ; u8
MLM_sub_el_return_pointers:   ds 2*CHANNEL_COUNT     ; void*[13]
MLM_instruments:              ds 2                   ; void* 
MLM_wram_end:

; ======== SSG Controller variables ========
SSGCNT_wram_start:
SSGCNT_volumes:			ds 3 ; u8[3]
SSGCNT_mix_flags:    	ds 1 ; u8 (Buffer for the YM2610's $07 Port A register)
SSGCNT_noise_tune:		ds 1 ; u8
SSGCNT_channel_enable:	ds 3 ; bool[3]
SSGCNT_notes:			ds 3 ; u8[3]

; IF THE ORDER OF THESE MACROS IS 
; CHANGED THEN "MLM_set_instrument_ssg"
; AND "SSGCNT_start_channel_macros"
; MIGHT STOP FUNCTIONING CORRECTLY 
SSGCNT_macros:
SSGCNT_mix_macro_A:		ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_mix_macro_B:		ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_mix_macro_C:		ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_vol_macro_A: 	ControlMacro 
	.ds 1+1+2+1+1+2
SSGCNT_vol_macro_B: 	ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_vol_macro_C:		ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_arp_macro_A: 	ControlMacro 
	.ds 1+1+2+1+1+2
SSGCNT_arp_macro_B: 	ControlMacro
	.ds 1+1+2+1+1+2
SSGCNT_arp_macro_C:		ControlMacro
	.ds 1+1+2+1+1+2
;SSGCNT_noise_macro:	ControlMacro

SSGCNT_wram_end:

; ======== FM ========
FM_wram_start:
FM_channel_lramspms:	ds FM_CHANNEL_COUNT             ; u8[4] (LRAA-PPP; Left & Right, Ams, Pms)
FM_channel_op_enable:	ds FM_CHANNEL_COUNT             ; u8[4] (4321----; op 4 enable; op 3 enable; op 2 enable; op 1 enable)
FM_channel_frequencies: ds FM_CHANNEL_COUNT*2           ; u16[4] (--BBBFFF'FFFFFFFF; Block, F-Num 2 & 1)
FM_operator_TLs:		ds FM_CHANNEL_COUNT*FM_OP_COUNT ; u8[FM_CH_COUNT][FM_OP_COUNT] (0~127; 127 is lowest, 0 is highest)
FM_channel_volumes:		ds FM_CHANNEL_COUNT             ; u8[4] (127 is lowest, 0 is highest)
FM_channel_key_on:		ds FM_CHANNEL_COUNT             ; bool[4] (If it isn't 0, then the channel will be played next IRQ and the value will be cleared)
FM_channel_enable:      ds FM_CHANNEL_COUNT             ; bool[4] (If it's 0, then the channel won't be touched by the FM IRQ routine)
FM_channel_algos:       ds FM_CHANNEL_COUNT             ; u8[4]
FM_wram_end:

; ======== PA ========
PA_wram_start:
PA_channel_volumes:  ds PA_CHANNEL_COUNT
PA_channel_pannings: ds PA_CHANNEL_COUNT	
PA_wram_end:

; ======== IRQ ========
IRQ_buffer:                   ds 2*IRQ_BUFFER_LENGTH ; u16[IRQ_BUFFER_LENGTH]
IRQ_buffer_idx_w:             ds 1                   ; u8
IRQ_buffer_idx_r:             ds 1                   ; u8

; ======== Others ========
EXT_2CH_mode: ds 1 ; u8 (0: 2CH mode off; 64: 2CH mode on)


total time: 0.1043 sec.
no errors
